<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>张华宁的笔记本</title>
 <link href="http://izhanghuaning.github.io/" rel="self"/>
 <link href="http://izhanghuaning.github.io"/>
 <updated>2014-04-03T17:16:34+08:00</updated>
 <id>http://izhanghuaning.github.io</id>
 <author>
   <name>张华宁</name>
   <email>izhanghuaning$163.com</email>
 </author>

 
 <entry>
   <title>BW客户端js之线程篇(十五)</title>
   <link href="http://izhanghuaning.github.io/books/2011/07/10/jsdg-chap13-jsthread.html"/>
   <updated>2011-07-10T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/07/10/jsdg-chap13-jsthread</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:浏览器中的js线程模型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js语言核心并不包含任何线程机制，并且客户端js在HTML5之前也没有定义任何线程机制。HTML5定义了一种后台线程的”Web Worker”，但客户端js还是严格按照单线程工作。&lt;/p&gt;

&lt;p&gt;单线程执行意味着浏览器必须在脚本和事件处理程序执行的时候停止相应用户输入，所以不能够编写需要长时间运算的脚本，如果需要这样的脚本需要分解为离散的子任务，可以使用setTimeout()、setInterval()方法在后台运行子任务，同时更新一个进度条向用户反馈。&lt;/p&gt;

&lt;p&gt;HTML5定义的”Web Worker”是一个在后台执行密集计算任务而不冻结用户界面的后台进程。它不能访问dom内容，不能和主线程或其他worker共享状态，只可以和主线程或其他worker通过异步事件进行通信，所以主线程不能检测并发性，并且worker不能修改js程序的基础单线程执行模型。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:客户端js时间线上的事件是如何分布的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;web浏览器创建document对象，并开始解析web页面，解析html元素和它们的文本内容后添加Element对象和Text节点到文档中。在这个阶段document.readstate的属性值是”loading”。&lt;/li&gt;

&lt;li&gt;当html解析器遇到没有async和defer属性的script标签时，它把这些元素添加到文档中，然后执行内联js脚本或者外联js文件代码。这些脚本会同步执行，并在脚本下载和执行时解析器会暂停。这样脚本就可以使用document.write()把文本插入到输出流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单的定义函数和注册后面使用的事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。同步脚本还能够且只能够看到它执行前渲染好的文档内容，包括自己script元素本身。&lt;/li&gt;

&lt;li&gt;当解析器遇到有async属性的script标签时，它们开始下载脚本，并且同时进行后面的文档解析。脚本会在它下载完成后尽快执行，但解析器不会停下来等它下载。异步脚本禁止使用document.write()方法。它也只能看到其script标签之前的内容。（因为是异步，其不能依赖其他异步生成的文档内容）&lt;/li&gt;

&lt;li&gt;当文档解析完成，document.readstate属性变成”interactive”。&lt;/li&gt;

&lt;li&gt;所有有defer属性的脚本，会按照它们在文档里出现顺序执行。defer延迟脚本其能访问整个文档树。延迟脚本禁止使用document.write()方法，因为浏览器解析已经完成了。&lt;/li&gt;

&lt;li&gt;浏览器在document对象上触发DOMContentLoaded事件。这标志程序执行从同步脚本执行阶段转换到异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。css文件、图片、js脚本等也可能还在下载。&lt;/li&gt;

&lt;li&gt;当图片等所有内容完成载入，并且所有的异步脚本完成载入和执行，document.readstate属性变为”complete”，web浏览器触发window对象的load事件。&lt;/li&gt;

&lt;li&gt;从此刻起，回调用异步事件，以响应用户输入事件、网络事件、计时器过期等。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmljs&quot;&gt;White:html中js时间线在首屏加载的意义？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js时间线没有指定什么时候文档开始对用户可见或什么时候web浏览器必须开始相应用户输入事件。在对于很长的文档或者非常慢的网络连接的时候，需要控制加载内容使用户能够尽快看到内容和操作文档，这就是首屏加载。&lt;/p&gt;

&lt;p&gt;一般来说首屏用到的文档内容（html）、交互（js）、视觉效果（css）需要尽快加载完成。其他内容可以通过动态加载方式继续加载和渲染。&lt;/p&gt;

&lt;p&gt;这就需要控制script代码、js文件、css文件、大图片等在html中的位置。首屏尽量不通过js代码进行布局和css渲染显示效果，如果需要则这些js代码和css尽量靠前(head中)，防止出现闪烁现象。同步执行的js代码应尽量少，并且需要放置在合适的位置(首屏内容)。用来响应首屏用户交互的代码尽量靠后（首屏内容后面）。其他html内容、js文件、css文件、图片等使用动态加载方式，延迟加载。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmlscriptasyncdefer&quot;&gt;White:html中script标签的async和defer属性的区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmlscriptasyncdefer_2&quot;&gt;White:html中script标签的async和defer属性的区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmlscriptasyncdefer_3&quot;&gt;White:html中script标签的async和defer属性的区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmlscriptasyncdefer_4&quot;&gt;White:html中script标签的async和defer属性的区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW客户端js概述篇(十四)</title>
   <link href="http://izhanghuaning.github.io/books/2011/07/05/jsdg-chap13-introduction.html"/>
   <updated>2011-07-05T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/07/05/jsdg-chap13-introduction</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:什么是客户端js？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js分为原生js、客户端js、服务端js。原生js就是ECMAScript，是js标准，在客户端和服务端是一样的。客户端js就是在浏览器中使用的js，定义了window等一系列对象和方法，基于安全原因限制很多，不能操作文件、网络等。服务端js是可以类似java等构建整个应用的，可以操作网络、数据库、文件等。&lt;/p&gt;

&lt;p&gt;客户端js主要是指window对象，window对象是所有客户端js特性和api的主要接入点，它表示web浏览器的一个窗口或者窗体，并且可以通过window来引用它。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitewindow&quot;&gt;White:什么是window对象？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; window对象是客户端js的全局变量。web浏览器每次向窗口或窗体载入新的内容，它都会开始一个新的js上下文，包含一个新创建的全局对象。但是当多个窗口或窗体在使用时，有一个重要概念，尽管窗口或窗体载入了新的文档，但是引用窗口或窗体的window对象仍然是一个有效引用。&lt;/p&gt;

&lt;p&gt;所以客户端js有两个重要的对象。客户端全局对象处于作用域链的顶级，并且是全局变量和全局函数定义的地方。每个窗口或全体的window对象都是独立的，因为它们都是真是window的一个代理，我们所说的window对象实际上就是window proxy，没有办法能够引用到真正的window对象。&lt;/p&gt;

&lt;p&gt;注意：如果web页面包含一个嵌入窗体（iframe），嵌入窗体中的js代码和文档窗口中的js代码会各自拥有独立的全局对象，它可被当作一个独立的窗口。两者的js代码一般情况不能相互访问（可以通过window.name、url的hash、jsonp等方式访问）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitedom&quot;&gt;White:什么是文档对象模型（DOM）？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 每个浏览器窗口、标签页和框架(iframe)都是由一个window对象所表示。每个window对象都有一个document属性引用了Document对象。Docuemnt对象表示窗口的内容，其并非是独立的，它是一个巨大的API的核心对象，叫做文档对象模型（DOM）。&lt;/p&gt;

&lt;p&gt;DOM是表示和操作HTML和XML文档内容的基础API。DOM是由Emenent组成的树形结构，其根节点就是Document对象。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmljs&quot;&gt;White:html中使用js的方式有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js程序可以通过Document对象和它包含的Element对象遍历和管理文档内容。它可以通过操作CSS样式和类，修改文档内容的呈现。可以通过注册适当的事件处理程序来定义文档元素的行为。&lt;/p&gt;

&lt;p&gt;html中使用js的方式有如下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内联，放置在&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;标签对之间。（少量js时可用）&lt;/li&gt;

&lt;li&gt;放置在由script标签的src属性指定的外部js文件中。（模块化，推荐）&lt;/li&gt;

&lt;li&gt;放置在html事件处理程序中，该事件处理程序由onclick等html属性指定。（不推荐）&lt;/li&gt;

&lt;li&gt;放在一个url中，这个url使用特殊的”javascript:”协议。（不推荐）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的推荐与否是根据：内容(html)和行为(js代码）应该尽量松耦合的原则，同理css也一样。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsscript&quot;&gt;White:js中script标签的用法？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; script标签有多种用法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内敛js代码。&lt;/li&gt;

&lt;li&gt;外联js文件。&lt;/li&gt;

&lt;li&gt;内敛数据（type=”data”）。&lt;/li&gt;

&lt;li&gt;内敛模板（jquery.tmpl）。&lt;/li&gt;

&lt;li&gt;动态引入js文件。&lt;/li&gt;

&lt;li&gt;实现jsonp。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_htmljs&quot;&gt;White: html中js是如何加载执行的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; html中的js代码首先需要加载，然后才能执行。&lt;/p&gt;

&lt;p&gt;第一阶段：打开一个新的窗口，这时候浏览器加载html文档，形成dom树，并在浏览器渲染加载内容。这时script标签只是加载的dom树中的一个元素，每加载完成一个script代码段(两个script构成封闭标签)或者js文件都会执行加载的js代码，这时候会阻塞浏览器的加载和渲染过程，也就是页面会卡死直到js代码执行完。js代码可能更改已经加载的dom的元素内容或者样式，所以js代码中操作的元素必须在之前加载好，否则会报错。如此反复直到页面加载完成。这个过程是同步操作。&lt;/p&gt;

&lt;p&gt;第二阶段：直到使用者操作页面上的按钮等元素，这时候异步调用相应的js代码，完成相应的操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：&lt;/em&gt;&lt;/strong&gt;第一阶段说js的加载执行是同步的，是指普通的写在页面script中的js代码是这样加载和执行的。如果通过动态构造script的方式则其执行是异步的，此时的加载和其后面的js代码的执行是异步的（同时进行的），后面的代码不能依赖动态加载的js内容。有些浏览器支持HTML5的script元素的defer和async属性，它们告诉浏览器链接进来的脚本不会使用document.write这样的改变dom的操作，也不会生成文档内容，因此浏览器可以在下载脚本时继续解析和渲染文档。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitehtmlscriptasyncdefer&quot;&gt;White:html中script标签的async和defer属性的区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; defer属性使得浏览器延迟脚本的执行，知道文档的载入和解析完成，并可以操作。async属性使得浏览器可以尽快执行脚本，而不用在下载脚本时阻塞脚本解析。如果两个属性同时出现，async起作用。defer是延迟执行，是在所有文档解析后再按照其出现顺序执行。async是异步执行，加载后立即无序执行（先加载好的先执行），async类似动态script加载方式。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js模块篇类(十三)</title>
   <link href="http://izhanghuaning.github.io/books/2011/06/30/jsdg-chap9-class.html"/>
   <updated>2011-06-30T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/06/30/jsdg-chap9-class</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中类是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 在js中，每个js对象都是一个属性集合，相互之间没有任何联系。当开发人员需要复用某个对象，想要共享某个对象的属性时，继承的概念就显现出来了。首先要定义一个模板类(class)，然后使用模板来生产相似的实例(instance)。每个实例都有模板定义的属性，是相似的对象，达到了复用的目的。&lt;/p&gt;

&lt;p&gt;在js中，继承是基于原型来实现的。如果两个实例从同一个原型对象继承了属性，我们就说它们是同一个类的实例，它们往往是由同一个构造函数创建并初始化的。&lt;/p&gt;

&lt;p&gt;关于构造函数请参见：&lt;a href=&quot;/books/2011/05/20/jsdg-chap4-expression-operators.html&quot;&gt;对象创建表达式和new关键字&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;调用构造函数的一个重要特征是：构造函数的prototype属性被用作新对象的原型，者意味着通过同一个构造函数创建的所有对象都继承字同一个对象，因此它们都是同一个类的实例。&lt;/p&gt;

&lt;p&gt;根据js约定俗称的做法，代表类的构造函数的首字母要大写，表明自己应该被new方式调用，如果使用普通方式调用就会出现意想不到的问题。new 关键字改变了函数的返回值、this，没有参数时可以省略括号。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中类的标识是构造函数么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js中类的唯一标识是原型对象(__proto__)。当且仅当两个对象继承自同一个原型对象时，它们才属于同一个类的实例。而初始化对象状态的构造函数则不能作为类的标识，两个构造函数的prototype可能指向同一个原型对象，那么这两个构造函数创建的实例属于同一个类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function Animal() {
		this.belongto = &amp;quot;animal&amp;quot;;
	}
	
	function Cat() {
		this.belongto = &amp;quot;cat&amp;quot;;
	}

	function Dog() {
		this.belongto = &amp;quot;dog&amp;quot;;
	}

	Cat.prototype = Animal.prototype;
	Dog.prototype = Animal.prototype;

	var c = new Cat;
	var d = new Dog;
	c.__proto__ === d.__proto__ //=&amp;gt;true

	var proto = new	Animal
	Cat.prototype = proto;

	var c2 = new Cat;
	c.__proto__ === c2.__proto__ //=&amp;gt;false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：o instanceof Object时，instanceof运算符不会检查o是否由Object()构造函数初始化而来，而会检查o是否继承自Object.prototype。instanceof语法强化了”构造函数是类的公有标识的概念”，是类的”外在表现”。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js中类(函数)和实例(对象)中有哪几个重要属性？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js类中的重要属性有prototype,实例（类的原型prototype）的重要属性有原型(__proto__)、构造函数(constructor)。类也是对象，所以类也有__proto__、constructor，不过这两个属性都是指向Function类的，基本不会使用。&lt;/p&gt;

&lt;p&gt;举例说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function Person() {}
	var p = new Person();

	Person.constructor === Function; //=&amp;gt;true
	Person.prototype === p.__proto__; //=&amp;gt;true
	Person.prototype.__proto__ === Object.prototype;//=&amp;gt;true
	Person.__proto__ === Function.prototype;//=&amp;gt;true
	Person.prototype.constructor === Person;//=&amp;gt;true

	p.__proto__ === Person.prototype;//=&amp;gt;true
	p.constructor === Person;//=&amp;gt;true&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_4&quot;&gt;White:js中检测实例的类的技术？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js中有三种检测实例的类的技术：instanceof运算符、consructor属性、构造函数的名字。每种方式都有其缺点。&lt;/p&gt;

&lt;p&gt;instanceof运算符：构造函数是类的公共标识，但原型是类的唯一标识。尽管instanceof运算符的右操作书是构造函数，但实际上是检测了对象的原型继承关系，而不是检测创建对象的构造函数。我们无法通过对象获得类名，只能检测对象是否属于指定的类名。&lt;/p&gt;

&lt;p&gt;constructor属性：并非所有的对象都有constructor属性。通过原型链每个对象都有constructor属性，但是可能是继承Object的，不是自己的。自定义对象原型需要自己定义constructor。通过默认的函数创建的对象默认有constructor属性，并且指向类构造函数。&lt;/p&gt;

&lt;p&gt;上述两种方式还有一个缺点，在多上下文的环境（比如两个页面），每个都有自己独立的全局变量和一组构造函数，一个页面的Array实例判断是否是另一个页面Array类是行不通的。&lt;/p&gt;

&lt;p&gt;构造函数的名称：并不是所有的函数都有名字，函数表达式没有名字。&lt;/p&gt;

&lt;p&gt;正式因为上述方式都有缺点，所以提出了”鸭式辩形”的策略，只关心行为，而不关心具体的类。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:”鸭式辩形”是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子。&lt;/p&gt;

&lt;p&gt;鸭式辩形的核心思想就是重行为轻类型。检测行为而不检测类型。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js模块篇(十二)</title>
   <link href="http://izhanghuaning.github.io/books/2011/06/25/jsdg-chap9-module.html"/>
   <updated>2011-06-25T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/06/25/jsdg-chap9-module</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js模块的含义是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;将代码组织到类中的一个重要原因是，让代码更加”模块化”,可以在不同场景实现代码的复用。但类不是唯一的模块化代码的方式。一般来讲模块是一个独立的js文件。模块文件可以包含一个类定义、一组相关的类、一个函数库、一些待执行代码等。只要以模块的形式编写代码，任何js代码都可以当作一个模块。&lt;/p&gt;

&lt;p&gt;js模块化保证了js代码的可维护性和可复用性，提高了开发效率，产生了一大批优秀的js类库，比如jquery、spine等等。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:命名空间是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 现在的程序的规模越来越大，不只是一个组织内部很多人会参与到项目中来，而且程序中会用到大量第三方开发的类库、组件等，如果大家都把变量、函数等定义在顶层作用域中，那么就会导致命名冲突和相互影响，导致程序不能正常工作，也会进入无法维护的境地。命名空间就是用来把变量、函数等划分进不同模块的方法，通过对程序划分模块来提高可维护性和避免命名冲突。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中命名空间使用函数来实现的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js中只有一种作用域，即函数作用域，在js中无法声明只有某个代码快内可见的变量的。所以必须通过函数来做命名空间，在这个函数内定义的变量不会污染全局命名空间和其他命名空间。&lt;/p&gt;

&lt;p&gt;最常用的方式有一个专门的名称：立即函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	(function() {
		//模块代码
	}());

	或者

	(function mymodule() {
		//模块代码
	})();&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两种方式基本等同，mymodule是函数表达式，最开始的()是告诉避免编译器把function当作函数声明语句。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js模块依赖关系管理是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;模块化解决的是js代码的松耦合，但是不同模块之间会有依赖管理，当模块很多时就迫切需要有一个模块依赖关系管理的功能。js本身不提供这样的功能。业界有commonjs模块规范可以参考，也有类似sea.js等库提供这样的功能。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js函数篇this(十一)</title>
   <link href="http://izhanghuaning.github.io/books/2011/06/20/jsdg-chap8-this.html"/>
   <updated>2011-06-20T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/06/20/jsdg-chap8-this</id>
   <content type="html">&lt;h4 id=&quot;whitethis&quot;&gt;White:this是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;this是一个关键字，不是变量，也不是属性名，js语法不允许给this赋值。和变量不同，关键字this没有作用域限制，嵌套的函数不会从外层函数中继承this，每个函数作用域即&lt;a href=&quot;/books/2011/05/15/jsdg-chap3-types-values-variables3.html&quot;&gt;变量对象VO&lt;/a&gt;都有自己的this。&lt;/p&gt;

&lt;p&gt;当内层嵌套函数想使用外层函数的this需要使用变量对this进行保存后使用。&lt;/p&gt;

&lt;p&gt;任何函数的调用都会隐式传入一个实参，这个实参是一个对象，方法调用的母体就是这个对象。如前所述，&lt;a href=&quot;/books/2011/06/10/jsdg-chap8-function.html&quot;&gt;函数有4中调用方式&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如下所示，每种调用方式的this都有其作用方式，能够找到this指向的对象是很关键的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitethisof&quot;&gt;White:this在方法调用o.f()中的作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;this是方法调用的核心，也就是谁正在调用方法,在f中的this就是o。如果f中包含嵌套函数g，那么函数g中的this 与f中的this没有任何联系，g中的this是window(global、undefined)。如果g中想要使用f中的this，一般的做法是在f中使用变量保存this的值，一般使用self或that作为变量名。这样在g中可以使用self指代f中的this。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitethisnew_f&quot;&gt;White:this在构造函数new f()中的作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在构造函数中,新构造的对象会被关联到this，所以this.x中的x会成为新构造的对象的属性，最后返回新建构造函数。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitethisfunctioncallo&quot;&gt;White:this在function.call(o)中的作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;function.call或apply是显示指定调用上下文的间接调用方式，其第一个参数就是函数中this的值。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitethisf&quot;&gt;White:this在函数调用f()中的作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在函数调用中，this的值是全局对象window。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js函数篇闭包(十)</title>
   <link href="http://izhanghuaning.github.io/books/2011/06/15/jsdg-chap8-closure.html"/>
   <updated>2011-06-15T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/06/15/jsdg-chap8-closure</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中的闭包是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;和大多数现代编程语言一样，js也采用词法作用域，也就是说函数的执行依赖语变量作用域，”这个作用域是在函数定义时决定的，而不是函数调用时决定的”。为了实现这种词法作用域，js函数对象的内部状态不但包含函数的逻辑代码，还必须引用当前的作用域链（调用上下文）。函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，看起来就像函数将变量”包裹”起来一样，称为”闭包”。&lt;/p&gt;

&lt;p&gt;这样来看每个函数内的变量都是”闭包”，但是实际中的概念却不是这个意思。&lt;/p&gt;

&lt;p&gt;在js中术语”闭包”一句话来说明就是：”从作用域A访问作用域B的变量，一般是只从外层作用域A访问内层作用域B。”&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中闭包的作用有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;从技术角度讲，所有的js函数都是闭包：它们都是对象，它们都关联作用域链。定义大多数函数时的作用域在调用函数时仍然有效，但这并不影响闭包。&lt;/p&gt;

&lt;p&gt;当调用函数时闭包所指向的作用域链和定义函数时的作用域链不是同一个作用域链时，事情就不一样了。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数作为返回值返回的时候往往会发生这种情况。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var scope = &amp;quot;global scope&amp;quot;;
	function checkscope() {
		var scope = &amp;quot;local scope&amp;quot;;
		function f() { return scope; }
		return f;
	}

	checkscope()();//=&amp;gt;local scope&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后一行返回的是”local scope”而不是”global scope”，这正是因为闭包作用的结果。闭包的这个特性强大的令人吃惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看起来像这些变量绑定到了其中定义它们的外部函数。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js中闭包的本质是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;按照java、c#等其他语言很难理解闭包，因为在这些语言中，函数内的局部变量在函数返回后就不可访问了。但是在js中却不是这样的，我们回想一下js中&lt;a href=&quot;/books/2011/05/15/jsdg-chap3-types-values-variables3.html&quot;&gt;如何定义作用域链&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们将作用域链描述为一个列表，而不是绑定的栈。每次调用js函数的时候，都会创建一个新的对象(变量对象VO)来保存局部变量，并把这个对象添加至作用域链。当函数返回的时候就从作用域链中删除这个绑定对象，它就会被当作垃圾回收掉。但是如果一个函数A定义了嵌套函数B，每个嵌套函数B都各自对应一个作用域链，并且这个作用域链指向一个变量对象VO。如果函数A正常返回，则嵌套函数B所对应的变量对象VO也会被垃圾回收处理。但是如果函数A返回了嵌套函数B，则存在了一个引用指向了嵌套函数B的变量对象VO，那么变量对象VO就不会被垃圾回收处理，所以从函数A所在的上下文仍然可以使用嵌套变量对象VO的属性（变量、参数等）。这就是js中”闭包的本质”。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_4&quot;&gt;White:js中闭包在实践中有哪些例子？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中闭包可以实现计数器，可以真正模拟私有变量，因为这些私有变量只能通过返回的函数访问。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function counter() {
		var n = 0 ;
		return {
			count: function() { return n++ ;},
			reset: function() { n = 0;}
		};
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里返回了一组方法组成的一个对象，返回对象的所有方法都共享一个私有变量n，只有返回对象的方法可以访问私有变量n。&lt;/p&gt;

&lt;p&gt;这种方式是js模块化的基础，后面会详细介绍&lt;a href=&quot;/books/2011/06/25/jsdg-chap8-namespace.html&quot;&gt;js模块化&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js函数篇(九)</title>
   <link href="http://izhanghuaning.github.io/books/2011/06/10/jsdg-chap8-function.html"/>
   <updated>2011-06-10T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/06/10/jsdg-chap8-function</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中的函数的重要意义是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中函数是核心中的核心。js中的函数是第一类对象，不同于java、C#等语言，可以说js的强大来源于其函数。&lt;/p&gt;

&lt;p&gt;函数是第一类对象代表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数可以赋值给变量。&lt;/li&gt;

&lt;li&gt;函数可以作为参数传入其他函数。&lt;/li&gt;

&lt;li&gt;函数可以作为返回值。&lt;/li&gt;

&lt;li&gt;函数可以嵌套使用。&lt;/li&gt;

&lt;li&gt;js中只有函数作用域。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中函数和方法有什么区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中函数调用还需要一个重要的概念：调用上下文，即this关键字的值。如果函数挂载在一个对象上，作为对象的一个属性，那么就称为该对象的方法。当通过对象来调用函数时，该对象就是此次调用的上下文，也就是this的值。&lt;/p&gt;

&lt;p&gt;没有直接使用对象来调用的函数（全局函数或者嵌套函数）就是普通意义上的函数，其this的值就是全局对象window（ECMAScript5好像严格模式下改了，成undefined了）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js中函数定义的方式有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中函数定义有三种方法：函数声明、函数表达式、new Function。&lt;/p&gt;

&lt;p&gt;函数声明(FD)的特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有一个特定的名称。&lt;/li&gt;

&lt;li&gt;在源代码中的位置：程序级 和 函数体内。&lt;/li&gt;

&lt;li&gt;在进入上下文阶段创建，会变量提前。&lt;/li&gt;

&lt;li&gt;影响变量对象（VO）。&lt;/li&gt;

&lt;li&gt;声明方式 &lt;code&gt;function funcName(arg,arg2,...) {...}&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;函数表达式(FE)特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可以有可选名称（只能在函数内使用，主要用于调试）。&lt;/li&gt;

&lt;li&gt;在源代码中的位置： 可以使用表达式的地方。&lt;/li&gt;

&lt;li&gt;在代码的执行阶段创建，不会变量提前。&lt;/li&gt;

&lt;li&gt;不会影响变量对象（VO）。&lt;/li&gt;

&lt;li&gt;声明方式&lt;code&gt;var funcName = function(arg1...) {...}&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;任何函数都是Function的一个实例，所以可以通过&lt;code&gt;var funcName = Function(&amp;quot;x&amp;quot;,&amp;quot;y&amp;quot;,&amp;quot;return x*y;&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Function方式的特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;允许js在运行时动态创建并编译函数。&lt;/li&gt;

&lt;li&gt;每次调用Function都会解析函数体，并创建新的函数对象。&lt;/li&gt;

&lt;li&gt;不使用本地作用域，只使用顶级作用域。&lt;/li&gt;

&lt;li&gt;此方法很少用到。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_4&quot;&gt;White:js中函数的调用方式有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中创建对象有四种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作为函数&lt;/li&gt;

&lt;li&gt;作为方法&lt;/li&gt;

&lt;li&gt;作为构造函数&lt;/li&gt;

&lt;li&gt;通过call或apply调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为函数和方法调用是普通调用，其最终也是通过apply实现的，call是apply的一个愈发糖。它们的区别就是调用上下文this。&lt;/p&gt;

&lt;p&gt;通过构造函数调用请参见&lt;a href=&quot;/books/2011/05/20/jsdg-chap4-expression-operators.html&quot;&gt;对象创建表达式和new关键字&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;call和apply间接调用，js中函数也是对象，和其他js对象没有什么不同，函数对象也有其自己的方法，其中call和apply可以用来间接调用函数。这两个方法需要指定所需的this的值，也就是说函数可以指定任何对象作为其this的值，哪怕哪个对象没有这个方法，这就可以实现函数借用。形式如&lt;code&gt;func.call(othis,arg1,arg2...);&lt;/code&gt;其中othis是传入的对象作为func的this。&lt;/p&gt;

&lt;p&gt;ECMAScript5新定义了一个bind方法，返回一个绑定了对象的方法，如&lt;code&gt;var g =f.bind(o); g();&lt;/code&gt;等同&lt;code&gt;f.call(o);&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;方法的调用还可以使用方括号的形式&lt;code&gt;o[&amp;quot;f&amp;quot;]();&lt;/code&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_5&quot;&gt;White:js中函数的形参和实参是什么概念？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中形参是可选的，实参是一个类数组对象（arguments)。形参是在定义函数时所声明的参&lt;code&gt;function f(arg1,arg2)&lt;/code&gt;中的arg1，arg2是形参，函数有一个length属性其值就是形参的个数。调用函数时传入的参数为实参，其不受形参影响，可多，可少。&lt;/p&gt;

&lt;p&gt;arguments是指向实参对象（Arguments）的引用，是一个类数组对象，可以通过索引来取得参数的值，并且通过索引和通过参数名arg1取得的是同一个值，通过任一方式操作都等价的，修改其中一个会影响另一个。&lt;/p&gt;

&lt;p&gt;arguments是一个对象，它也有自己的属性，callee代表正在执行的函数，caller代表调用正在执行的函数的函数（外层函数）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejquery&quot;&gt;White:jquery中常见的参数对象是什么意思？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;函数中的参数越多，调用起来就越不方便，所以引出了参数对象的概念dto(data transfer object)，把所有参数封装为一个对象，对像赋值后直接传递给函数。对于jquery等类库基本都需要支持option的参数对象。&lt;/p&gt;

&lt;p&gt;实现类库注意事项有如下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过立即函数封装模块，只提供最少的全局变量。&lt;/li&gt;

&lt;li&gt;提供配置参数对象。&lt;/li&gt;

&lt;li&gt;只提供构造函数，其他方法通过参数调用方法。&lt;/li&gt;

&lt;li&gt;支持链式调用，也支持对象显示功能，防止火车事故的难以跟踪。&lt;/li&gt;

&lt;li&gt;最好支持extend和include等方式对类库进行扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js数组篇(八)</title>
   <link href="http://izhanghuaning.github.io/books/2011/06/05/jsdg-chap7-array.html"/>
   <updated>2011-06-05T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/06/05/jsdg-chap7-array</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中数组是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;数组是值的有序集合，每个值在数组中都有一个位置，以从0开始的数字表示，称为索引。js中的数组就是一个特殊的对象，这个对象的属性名恰好是数字，并且它有一个可以自己维护值的属性length。&lt;/p&gt;

&lt;p&gt;在js中数组是一个非常重要的概念，js中的集合就是通过数组来实现的，提供了很多集合的操作方法。绝大多数数组方法都支持回调函数，这也就是高阶函数的概念。&lt;/p&gt;

&lt;p&gt;js中数组有如下特征：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当有新的元素添加到列表中时，自动更新length属性&lt;/li&gt;

&lt;li&gt;设置length为一个较小的值将截断数组&lt;/li&gt;

&lt;li&gt;从Array.prototype继承了一些方法&lt;/li&gt;

&lt;li&gt;其类属性(class)为“Array”&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中数组有哪些方法？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;ECMAScript3中的方法主要有；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;join(splitor)将数组中所有元素都转化为字符串并连接在一起，并用分割符进行隔离，默认分割符是逗号(,)。&lt;/li&gt;

&lt;li&gt;reverse()将数组中元素的顺序逆序排列，并返回逆序的数组，修改原数组。&lt;/li&gt;

&lt;li&gt;sort(callback)将数组中元素通过callback排序后返回排序后的数组，修改原数组。&lt;/li&gt;

&lt;li&gt;concat(elements)把elements连接到原数组后面，如果elements中有数组则一次扁平化后连接其元素。修改原数组。&lt;/li&gt;

&lt;li&gt;slice()返回数组的一个片段或字数组，原数组不变。其参数是”顾头不顾尾”，包含起始点元素，不包含结束点元素。&lt;/li&gt;

&lt;li&gt;splice()在数组中插入或删除元素，修改原数组。&lt;/li&gt;

&lt;li&gt;push()、pop()将数组当作栈使用。修改原数组。&lt;/li&gt;

&lt;li&gt;unshift()、shift()类似栈，但是是对头进行操作。修改原数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ECMAScript5增加了新方法如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;forEach(callback)遍历数组并为每个元素调用callback，返回修改后的数组。修改原数组。&lt;/li&gt;

&lt;li&gt;map(callback)遍历数组并为每个元素调用callback，返回新数组。&lt;/li&gt;

&lt;li&gt;filter(callback)返回满足callback的原数组的一个子集的新数组。&lt;/li&gt;

&lt;li&gt;every(callback)、some(callback)数组的逻辑判定，是否满足callback，返回true或false。&lt;/li&gt;

&lt;li&gt;reduce(callback,start)使用callback对数组进行组合，返回一个单个值。&lt;/li&gt;

&lt;li&gt;indexOf(el)搜索数组给出el元素的索引值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组还可以定义很多方法，这些需要自己去实现。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:什么是类数组对象？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;是一个对象，却具有数组的特征，可以通过Array.prototype.slice.call(o,0,o.length-1)转化为真正的数组。数组的很多方法都可以直接使用于类数组对象。最常见的就是Arguments对象。&lt;/p&gt;

&lt;p&gt;Arguments是每个函数体中都有的参数对象，代表了实际传入函数的参数，将在下一篇函数篇进行详细介绍。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js对象篇(七)</title>
   <link href="http://izhanghuaning.github.io/books/2011/05/30/jsdg-chap6-object.html"/>
   <updated>2011-05-30T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/05/30/jsdg-chap6-object</id>
   <content type="html">&lt;h4 id=&quot;whitejsjs&quot;&gt;White:js中什么是js对象？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在js中类型分为原始类型和对象类型，除了原始类型string、number、bool、null、undefined外的其他所有类型都属于对象类型。对象最基本的形式是“名/值”对的无序集合。如&lt;code&gt;var o = {x:1,y:2}&lt;/code&gt;，其中x、y为对象o的属性，其值可以为任何类型。访问对象的值可以通过点(.)形式，也可以通过数组索引（&lt;code&gt;o[&amp;quot;x&amp;quot;]&lt;/code&gt;）的形式，一般采用前者，但是后者可以实现很多动态强大功能。&lt;/p&gt;

&lt;p&gt;对象包括内置对象(ECMASCript原生对象）、宿主对象（浏览器定义的）、自定义对象（程序员定义的）。&lt;/p&gt;

&lt;p&gt;对象属性不仅是字符串，属性(property)本身也有自己的属性(attribute)，对象不仅可以访问自己的属性，也可以访问其继承的属性，这种继承是通过js的“原型链”的核心功能实现的。&lt;/p&gt;

&lt;p&gt;对象是可变的，我们通过引用而非值来操作对象。对象最常见的用法是创建、设置、查找、删除、检测和枚举它的属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs&quot;&gt;White:js中创建对象有哪些方式？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中创建对象有三种方式：对象直接量、new、Object.create()；&lt;/p&gt;

&lt;p&gt;对象直接量就是直接通过花括号进行初始化对象，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var empty = {};
	var point = {x:1, y:1};
	var book = {
		&amp;quot;title&amp;quot;:&amp;quot;Javascript&amp;quot;,
		&amp;quot;for&amp;quot;:&amp;quot;all audiences&amp;quot;,
		&amp;quot;author&amp;quot;:{
			firstname:&amp;quot;huaning&amp;quot;,
			lastname:&amp;quot;zhang&amp;quot;
		}
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;new方式请参见&lt;a href=&quot;/books/2011/05/20/jsdg-chap4-expression-operators.html&quot;&gt;对象创建表达式和new关键字&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Object.new(proto，options)方式是ECMAScript5新定义的，它是Object的一个静态方法，其中第一个参数表示以proto作为所创建的对象的原型(__proto__)，第二个参数是一个对象，用来初始化所创建的对象的属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var nullobject = Object.create(null);//这个对象不包含任何方法，是真正的空对象,同null类似。
	var emptyobject = Object.create(Object.prototype);//这个对象是普通空对象，其原型是Object.prototype
	//ECMAScript5的Object.crate方法模拟
	function inherit(p) {
		if(p == null) throw TypeError();
		if(Object.create) return Object.create(p);
		var t = typeof p;
		if(t !== &amp;quot;object&amp;quot; &amp;amp;&amp;amp; t!== &amp;quot;function&amp;quot;) throw TypeError;
		function f() = {};
		f.prototype = p;
		return new f();
	}
	//new f()作为临时对象，是为了函数作为返回值时，隔离不同的新创建对象和原型p的关联关系。
	
	//举例说明：
	function Animal() {name=&amp;quot;p&amp;quot;};
	function Cat = inherit(Animal);
	Cat.prototype.say = function(){return &amp;quot;miao&amp;quot;;}
	function Dog = Inherit(Animal);
	Dog.prototype.say = function() {return &amp;quot;wang&amp;quot;;}
	
	//如果不使用临时对象，则Dog和Cat会相互影响，可以自己尝试。&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejspropertyattribute&quot;&gt;White:js中对象的属性(property)本身有哪些特性(attribute)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;属性的特性包括名、值、可枚举性、可配置性。&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor()可以获得某个对象的属性描述符。&lt;/p&gt;

&lt;p&gt;Object.defineProperty()传入要修改的对象、要修改的属性及属性描述符对象，即可修改某种属性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsattribute&quot;&gt;White:js中对象有哪些属性(attribute)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;对象的属性有原型属性(__proto__）、类属性(class)、可扩展性。&lt;/p&gt;

&lt;p&gt;原型属性在下面详细讲解。&lt;/p&gt;

&lt;p&gt;类属性是一个字符串，用来表示对象的类型信息，通过Object.prototype.toString.call(o)方式取得&lt;code&gt;[xxx class]&lt;/code&gt;形式字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	//下面函数可以取得对象类型
	function classof(o) {
		if(o === null) return &amp;quot;Null&amp;quot;;
		if(o === undefined) return &amp;quot;Underfined&amp;quot;;
		return Object.prototype.toString.call(o).slice(8, -1);
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可扩展性配合属性的特性可以实现只读对象等特殊对象,用的少，现用现查不具体讲解。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs__proto__&quot;&gt;White:js中对象原型(__proto__)是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; js是一种面向对象的语言，面向对象的特征有封装、继承、多态。js完全可以写出像java那样的Class式的程序，它是通过&lt;code&gt;function ClassName（）&lt;/code&gt;这样的方式来实现Class的。有了Class可以把数据和方法封装起来，而且对于弱类型的js来说多态更是容易实现，最显而易见就是”鸭式辩型”的方式。剩下的继承在js中就是通过原型来实现的，大多数语言的继承是通过模板即Class方式实现，但js是通过原型来实现的。 下面是示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function Animal() { name=&amp;quot;animal&amp;quot;; };
	var animal = new Animal();
	animal.name;//=&amp;gt;animal
	animal.say();//错误，未定义say
	Animal.prototype.say = function(){return &amp;quot;I am &amp;quot;+ this.name;}
	animal.say();//=&amp;gt;I am animal;
	animal.__proto__ === Animal.prototype;//=&amp;gt;true
	Animal.__proto__ === Function.prototype;//=&amp;gt;true&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs__proto__prototype&quot;&gt;White:js中对象原型(__proto__)和prototype有什么区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1. 所有对象都有__proto__，但不是每个对象都有prototype。
	2. prototype是函数(function)特有的。
	3. 函数也是对象，它既有__proto__(Function.prototype)，也有prototype(new f().__proto__);
	4. Function的__proto__和prototype是同一个。
	5. Object.prototype.__proto__ 是null。
	6. Object.prototype是所有对象的最终__proto__。
	7. Object是一个函数，Object.prototype是一个对象。
	8. Object.prototype必须是一个对象，而不能是函数。&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsjson&quot;&gt;White:js对象序列化json对象方法有哪些？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; json序列化方法有JSON.stringify(o)和JSON.parse(s)来进行序列化和反序列化。json只支持对象、数组、字符串、数字、true、false、null，不支持日期、函数、Regxp、Error等的序列化。json字符串中日期建议以字符串或者timestamp形式。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js表达式篇eval(六)</title>
   <link href="http://izhanghuaning.github.io/books/2011/05/25/jsdg-chap4-expression-operators2.html"/>
   <updated>2011-05-25T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/05/25/jsdg-chap4-expression-operators2</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White:表达式计算是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js同许多解释性语言一样，可以解释并运行由js代码组成的字符串，并产生一个值。这就是表达式运算，在js中通过全局函数eval()来实现这个工作。对于eval记住一句话：”eval()是魔鬼”，能不用就不要用。&lt;/p&gt;

&lt;p&gt;eval只有一个参数，如果传入的参数不是字符串，它直接返回这个参数，否则它会把参数字符串当作js代码来解释，如果解释失败则抛出错误，成功则开始执行。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval&quot;&gt;White:eval有哪些需注意的地方？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;记住一句话：”eval()是魔鬼”，能不用就不要用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在你觉得需要使用eval方法的时候，请再三考虑一下是否有更好的方式来替代eval。&lt;/li&gt;

&lt;li&gt;eval只能执行单独有语义的代码，不能作为函数的一部分来运行，比如&lt;code&gt;eval(&amp;quot;return;&amp;quot;)//=&amp;gt;错误&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;非直接调用eval(使用&lt;code&gt;geval = eval;&lt;/code&gt;别名)时，它使用全局对象作为上下文作用域，并且无法读、写、定义局部变量和函数。&lt;/li&gt;

&lt;li&gt;eval别名调用方式允许我们执行一些对上下文没有任何依赖的代码片段。&lt;/li&gt;

&lt;li&gt;对待eval最好把它当作一个运算符，而不是一个函数。&lt;/li&gt;

&lt;li&gt;在严格模式下，eval可以查询和修改局部变量，但是不能在局部作用域定义新的变量或函数。&lt;/li&gt;

&lt;li&gt;ajax返回的json送入eval进行处理时需要对json加括号包住&lt;code&gt;eval(&amp;quot;(&amp;quot;+json+&amp;quot;)&amp;quot;)&lt;/code&gt;来转成对象处理,但是json处理一般是用JSON.parse进行解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval_2&quot;&gt;White:为什么说”eval是魔鬼”？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;主要有以下几个原因:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用eval的代码晦涩难懂，不容易维护。&lt;/li&gt;

&lt;li&gt;eval包含安全隐患，它可以执行可能被篡改过的代码，这是在处理ajax请求的json响应的常见的反模式。&lt;/li&gt;

&lt;li&gt;eval使用了调用者的变量作用域环境，即它查找变量的值和定义新变量的操作和局部作用域的代码完全一样，会改变调用者（局部或全局）的变量对象VO。&lt;/li&gt;

&lt;li&gt;优化或者js压缩工具不能很好的对包含eval的代码进行优化。&lt;/li&gt;

&lt;li&gt;setInterval()、setTimeout()、new Function()这些方法传递字符串参数的时候和eval类似，应尽量避免传递字符串给它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval_3&quot;&gt;White:使用哪些方式可以尽量安全eval的方式？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;有一些方式可以替换或者较好方式使用eval，主要有以下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用new Function(str)来替代eval，str中使用var定义的变量会在局部函数作用域运行，不会自动成为全局变量。&lt;/li&gt;

&lt;li&gt;使用立即函数封装eval的调用，也可避免其中var定义的变量自动成为全局变量。&lt;/li&gt;

&lt;li&gt;使用new Function的方式只能看到全局作用域，不影响局部作用域链。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js表达式、运算符篇(五)</title>
   <link href="http://izhanghuaning.github.io/books/2011/05/20/jsdg-chap4-expression-operators.html"/>
   <updated>2011-05-20T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/05/20/jsdg-chap4-expression-operators</id>
   <content type="html">&lt;h4 id=&quot;whitejs&quot;&gt;White:js中什么是表达式和运算符？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在js中表达式（expression）是一个短语，js解释器会将其计算出一个结果。程序中的常量是最简单的一类表达式。变量名也是一种简单表达式，它的值就是赋值给变量的值。复杂表达式是由简单表达式组成的，常用的方法是使用运算符(operator)。运算符按照特定的运算规则对操作数进行运算，并计算出新值。&lt;/p&gt;

&lt;p&gt;表达式主要包含原始表达式(直接量(常量)、关键字(true,false，null,this)、变量），对象和数组初始化表达式（&lt;code&gt;var p = {x:2, y:3}&lt;/code&gt;、&lt;code&gt;var days = [1,2,3]&lt;/code&gt;） ，函数定义表达式（&lt;code&gt;var sum = function(a,b) {return a + b}&lt;/code&gt;)，属性访问表达式(&lt;code&gt;p.x&lt;/code&gt;、&lt;code&gt;p[&amp;quot;y&amp;quot;]&lt;/code&gt;、&lt;code&gt;days[0]&lt;/code&gt;），调用表达式（调用函数或方法的语法表示），对象创建表达式(new)，运算表达式（见下面运算符所示）等。&lt;/p&gt;

&lt;p&gt;js中的运算符主要用于算术表达式(+、-、*、/)、比较表达式(&amp;lt;、===、&amp;gt;）、逻辑表达式（&amp;amp;&amp;amp;、||、！）、赋值表达式（=）等。大多数运算符都用标点符号表示，比如+-*/，也有一些运算符用关键字表示，比如delete、instanceof、typeof、void等。运算符是有优先级和结合性(一元操作符、赋值、三元条件运算符都是右结合)的，关于运算符可参见下图：&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:什么是左值,什么是表达式副作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;左值是一个术语，它指“表达式只能出现在运算符的左侧”。在js中变量、对象属性、数组元素均是左值。ECMAScript规范允许内置函数返回左值，但是自定义函数不能返回左值。&lt;/p&gt;

&lt;p&gt;表达式副作用是指本来计算表达式（比如&lt;code&gt;2*3&lt;/code&gt;)不会对程序的运行状态造成任何影响，程序后续的计算也不会受到该表达式运算的影响，但是有一些表达式在即算后会产生上述影响，这就是表达式的副作用。&lt;/p&gt;

&lt;p&gt;会产生副作用的表达式有：赋值、自增、函数调用、对象创建、delete等。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:调用表达式怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;调用表达式(invocation expression）是一种调用（或者执行）函数或方法的语法表示。当调用表达式进行求值的时候，首先计算函数表达式，然后计算参数表达式，得到一组参数。然后实参的值被依次传递给形参，这些形参是定义函数时指定的，接下来执行函数体。执行后返回该函数的返回值，如果没有则返回undefined。&lt;/p&gt;

&lt;p&gt;在js中函数调用有两种方式普通调用和new调用，这两种方式调用同一个函数，其意义确实差异巨大。普通方式是通过func.apply方式来对函数过程进行调用，而new方式是对象创建表达式，详细见下面的new关键字的理解。&lt;/p&gt;

&lt;p&gt;函数表达式本身可以说没有副作用，但是因为函数体内部的语句或者表达式可能会产生副作用，所以这种情况下一般说函数表达式是有副作用的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitenew&quot;&gt;White:对象创建表达式和new关键字怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;对象创建表达式(object creation expression)创建一个对象并调用一个函数(这个函数称作构造函数)初始化对象的属性。js通过new关键字来进行对象创建，new关键字调用的函数与普通调用方式有2点不同：改变了上下文和改变了返回值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;new的本质&lt;/em&gt;&lt;/strong&gt;，new关键字本质上也是调用函数的方式（普通函数调用是通过func.apply或func.call方式调用），它的特殊性在于把函数当作构造函数来执行，并最终创建一个对象。其过程如下：js解释器new关键字时知道是创建对象的时候了，进行了如下步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先传见一个新的空对象（{}）。&lt;/li&gt;

&lt;li&gt;然后把这个对象赋值给this（自定义函数无法给this赋值）。&lt;/li&gt;

&lt;li&gt;构造函数的prototype作为新对象的原型(__proto___)。&lt;/li&gt;

&lt;li&gt;把构造函数作为新对象的原型(__proto__)的constructor。&lt;/li&gt;

&lt;li&gt;调用构造函数把传入的参数和构造函数中赋值给this的属性都作为新对象的属性&lt;/li&gt;

&lt;li&gt;如果构造函数没有return则把这个构造好新对象作为返回值。&lt;/li&gt;

&lt;li&gt;如果有return则把其返回的对象作为最后的返回值，即创建表达式计算的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_3&quot;&gt;White:比较运算符中的==和===的区别是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;简单来说==会进行类型转换后比较，而===不进行类型转换直接比较，===也是严格比较,应该只使用===。&lt;/p&gt;

&lt;p&gt;===规则为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果两个值类型不同，则它们不相等。&lt;/li&gt;

&lt;li&gt;如果两个值都是null或者undefined，则它们不相等。&lt;/li&gt;

&lt;li&gt;如果两个值都是true或者都是false，则相等。&lt;/li&gt;

&lt;li&gt;任何一个是NaN则不相等，NaN需要使用!==来判断。&lt;/li&gt;

&lt;li&gt;如果两个值为数字且数值相等，则相等。0和-0相等。&lt;/li&gt;

&lt;li&gt;两个字符串只有它们所对应存储的16位数字完全相等，则它们相等。（字符串实际上是16位整数数值组成的序列，同一字符串但编码不同就是2个不同的整数序列，所以不相等。）&lt;/li&gt;

&lt;li&gt;如果两个引用值指向同一个对象、数组或者函数，则相等，只比较引用不考虑具体的值的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==规则就是===规则然后每一个都允许进行类型转换后尝试比较，比如&lt;code&gt;null==undefined //=&amp;gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;对象转换原始值是除了日期先进行toString，其他都是先valueof后调用toString进行转换。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_4&quot;&gt;White:对象转换为原始值有哪些规则？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;所有对象都继承了2个转换方法，第一个是toString（），它的作用是返回一个反映对象的字符串，默认是&lt;code&gt;[object Object]&lt;/code&gt;,我们可以通过Object.prototype.toString.call(o)来得到o的实际类型，比如&lt;code&gt;[object String]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第二个是valueof()，如果存在任意原始值，它就默认将对象转换未它的原始值。但是大多数对象无法真正表示为一个原始值，因此默认的valueof简单返回对象本身，而不是一个原始值。&lt;/p&gt;

&lt;p&gt;对象到字符串的转换步骤（先toString后valueof）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if(o.has_method(toString) &amp;amp;&amp;amp; o.toString()===&amp;quot;原始值&amp;quot;)
	{
		return o.toString().转成字符串;
	} else if(o.has_method(valueof) &amp;amp;&amp;amp; o.valueof() === &amp;quot;原始值&amp;quot;)
	{
		return o.valueof().转成字符串；
	} else
	{
		throw 异常；
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象到数字的转换步骤（先valueof后toString）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if(o.has_method(valueof) &amp;amp;&amp;amp; o.valueof() === &amp;quot;原始值&amp;quot;)
	{
		return o.valueof().转成数字；
	} else if(o.has_method(toString) &amp;amp;&amp;amp; o.toString()===&amp;quot;原始值&amp;quot;)
	{
		return o.toString().数字;
	} else
	{
		throw 异常；
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象转换原始值是除了日期先进行toString，其他都是先valueof后调用toString进行转换。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js变量篇作用域链(四)</title>
   <link href="http://izhanghuaning.github.io/books/2011/05/15/jsdg-chap3-types-values-variables3.html"/>
   <updated>2011-05-15T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/05/15/jsdg-chap3-types-values-variables3</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;本篇定位于进阶篇，初次接触javascript的可跳过本篇&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;whitejsstackheap&quot;&gt;White:什么是上下文调用栈，js中的栈(stack)和堆(heap)的理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;正如前一篇模拟js解释器所示，js代码初始所在的作用域为顶级作用域。js只有一种作用域即函数作用域，每当代码执行到一个函数的时候，暂停执行外层作用域,并保留当前代码的上下文和执行位置，然后进入一个新的作用域，产生一个新的上下文，如此反复就构成了一个上下文栈式结构，每一层都是一个作用域范围即一个上下文，进入新的作用域类似于入栈push一个新上下文，从内层作用域返回类似于出栈pop出当前上下文，所以叫做上下文调用栈。当代码在内层作用域执行完以后返回外部作用域的代码位置，丢掉内层的上下文(闭包情况例外)，使用外层上下文继续向下进行,所有函数执行完返回顶级作用域，这时候window对象作为当前上下文对象（变量对象VO），当前包含上下文的对象即活动对象。&lt;/p&gt;

&lt;p&gt;说到堆栈，很多人当希望深入了解某些代码的执行过程（比如java、c#、javascript等），喜欢模拟内存中数据进行分析，这是一个很好的方法,对于理解程序很有帮助。在java中原始值是通过栈来维护的，而引用值是通过堆来管理的，这主要是考虑程序的效率，栈速度快但容量小，堆容量大但相对慢，堆里面的对象是通过new的方式来分配空间并创建的，也涉及到垃圾回收的管理。&lt;/p&gt;

&lt;p&gt;但是在javascript对我们可以说只有堆，没有栈结构，因为有变量对象VO的概念，所以所有的数据都是以堆的形式管理的，解释器不直接取数据，都是通过变量对象VO取数据，这是很重要的一点，尤其是想要理解闭包的概念。javascript的内存中数据结构很简单VO作为上下文，通过链表的形式链接所有的VO，链接起来就是上下文调用栈，这里的栈只是一个描述性概念，不是内存管理数据的方式，所以&lt;strong&gt;&lt;em&gt;“正式的称呼叫作用域链”&lt;/em&gt;&lt;/strong&gt;，凸显了链这个结构。&lt;/p&gt;

&lt;p&gt;下面会继续讲解VO概念。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitevariable_objectactive_object&quot;&gt;White:什么是变量对象（variable object）和活动对象(active object)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;如前所述，声明全局变量，它会成为一个全局对象window的一个属性，那么局部变量呢，按照统一性进行推论应该成为某个对象的属性。这个对象即是假设的上下文对象VO。当代码执行的时候，会形成一个作用域链，在每个作用域有一个由很多变量、参数、函数等组成的上下文，包含上下文中的内容的对象被成为变量对象VO，解释器正在执行的作用域的VO就是活动对象AO。&lt;/p&gt;

&lt;p&gt;VO对象对我们是透明（不可见）的，它由解释器来创建和维护的，我们代码不能操作VO。但是我们可以通过chrome等的开发者工具可以查看到scope variables即作用域链，里面有各个VO。我假设的VO对象结构是下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var VO = {
		var1:&amp;quot;var1&amp;quot;,
		function1:function() {},
		arg1:arg1,
		.//变量、函数、参数都编程了VO对象的属性
		.//还有个作用域链的属性和this属性
		.//注意：表达式不能成为VO的属性
		ScopeChains:[VO的上面的属性 + 上级ScopeChains],
		this:特殊值//=》函数的调用者被关联到this。

	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ScopeChains和this两个属性不进入作用域链查找，查找时先看当前VO有没有相应属性，没有则进入上一级的ScopeChains查找。this是javascript的最核心内容（也可能是之一），后面应该也要单独讲解,请参见&lt;a href=&quot;/books/2011/06/20/jsdg-chap8-this.html&quot;&gt;javascript this详解&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitevo__proto__objectprototype&quot;&gt;White:VO既然是个对象，那么它的原型(__proto__)是什么？对象Object.prototype？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;我有个假设是函数级VO的原型是null，因为我在chrome的开发者工具做了如下测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function test() { return toString() }
	test();//=&amp;gt;[object window]
	window.toString = function() {return &amp;quot;window toString&amp;quot;}
	test();//=&amp;gt;window toString&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试中的toString()方法在test的作用域没有定义，但是Object中有这个方法，它的返回值就是[object xxxx]的形式，所以第一次调用的就是Object的toString方法。这个调用是调用的VO的原型的toString方法还是通过window调用的呢？所以把window的toString重写，然后再次调用，发现是调用的window的toString方法。根据作用域链，解释器应该先从test的VO寻找toString方法，既然是从VO对象中查找属性则涉及到原型链查找，如果VO的原型链有Object，应该会直接调用Object的toSring方法。但是后面证实解释器是从test的VO，找到window的VO,然后调用的window的toString方法，所以我假设VO的原型(__proto__)是null，所以VO直接沿着作用域链的VO查找所有参数、变量和函数，而不会去原型链查找。&lt;/p&gt;

&lt;p&gt;但是到了window的VO呢？似乎不能满足上面假说，因为调用了window的toString方法，这个方法是从其原型链的Object得到的，这里是有冲突的，所以我的另一个假说是window的VO引用了window自身，从chrome也可以看到这个意思(Global window)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里的假说有待商榷，希望有了解的能够指正，我没有去研究js引擎的内容，谢谢&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:作用域链是如何形成的呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在最顶级作用域中，作用域链只有一个全局对象组成，即window VO。在不包含嵌套函数的函数体内，作用域链上有两个对象，第一个是函数自身VO，还有其外层的window VO。如果函数中还有嵌套函数，那么内部嵌套函数的作用域链就是自身VO + 所有的外层ScopeChains，一直包含到window VO。作用域链是在解释器进入函数的时候进行重新定义（或者说延伸），不断进行 新的ScopeChains = 自身VO + 外层ScopeChains。&lt;/p&gt;

&lt;p&gt;嵌套函数更加特殊的地方在于，因为作用域链是在进入函数时重新定义的，所以嵌套函数的作用域链在每次执行外部函数时定义的，虽然嵌套函数的代码相同，但关联这段代码的作用域链却不相同。&lt;/p&gt;

&lt;p&gt;作用域链有几个特殊情形是with和try…catch,这两种情况都会产生一个新的作用域上下文即变量对象VO,附加到整个作用域链最前面，即在with中的ScopeChains = with_VO + 当前函数Scopehains。try…catch也是一样的。&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js变量篇(三)</title>
   <link href="http://izhanghuaning.github.io/books/2011/05/10/jsdg-chap3-types-values-variables2.html"/>
   <updated>2011-05-10T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/05/10/jsdg-chap3-types-values-variables2</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White:变量是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;正如前面类型篇所讲，变量就是一个标签，贴到了“值alue”上面，代码可以通过变量来操作它所代表的值，主要是为了方便复用。&lt;/p&gt;

&lt;p&gt;变量根据是否可以改变分为普通变量和常量，常量就是赋值之后不能二次赋值（改变）的特殊只读变量，js没有真正声明常量的语法，基本是约定俗称的全大写的变量表示常量。&lt;/p&gt;

&lt;p&gt;js的变量根据其作用域(有效范围)分为私有变量、局部变量、全局变量等，js的作用域只有函数作用域，外层作用域的变量可以穿透作用域到内层作用域，当内外层作用域的变量冲突的话，内层作用域的变量起作用（覆盖了外层），这实际上是变量的作用域链的查找规则决定的，后面会深入探讨作用域链。还有一种特殊的能跨作用域的变量是闭包的概念，这也是一个进阶的内容，放在后面单独开出一章来讲解。一句话理解闭包就是从作用域A操作（访问）作用域B中的变量,基本是指外部访问内部作用域的变量。&lt;/p&gt;

&lt;p&gt;js中没有真正声明私有变量的语法，约定俗称是变量前面或者后面加上一个或两个下划线表示该变量为私有变量（_name,name_,__proto__等），作者不希望其他人使用这些变量，此所谓防君子不防小人，别人照样能随意操作你的私有变量。真正实现的私有变量是通过闭包来实现的，但是性能效率比较低，关于闭包会详细说明请参见&lt;a href=&quot;/books/2011/06/15/jsdg-chap8-closure.html&quot;&gt;javascript闭包详解&lt;/a&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:变量作用域是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;变量的作用域是指”程序源代码中定义这个变量”的区域。js的作用域只有一种，函数作用域。全局作用域可以看作一种特殊的函数作用域，类似语程序的入口函数(main)的概念，所有的js代码都是在全局作用域被解释器顺序解释并执行，遇到执行函数时则进入函数作用域(function)解释并执行。&lt;/p&gt;

&lt;p&gt;全局对象（一般是window）是js解释器加载js代码时候创建的特殊对象（上下文对象或活动对象），所有未声明在其他函数作用域(function)的变量、函数都会成为window对象的属性，它们在代码中的任何地方（所有作用域中）都是可见的。如下所示：&lt;/p&gt;

&lt;p&gt;……………隐藏的js文件或script开始标签&amp;lt; script&amp;gt;………………..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var scope = &amp;quot;global&amp;quot;;
	function checkscope() {
		var localscope = &amp;quot;local&amp;quot;;
		scope_without_var = &amp;quot;scope_without_var&amp;quot;;
		return scope + &amp;quot; &amp;quot; + localscope + &amp;quot; &amp;quot; + scope_without_var;
	}
	scope;//=&amp;gt;global
	localscope;//=&amp;gt;未声明错误
	scope_without_var;//=&amp;gt;未声明错误,注意还没有执行checkscope，解释器还不知道它的存在
	
	checkscope();//=&amp;gt;global local scope_without_var，这里执行了checkscope
	
	scope;//=&amp;gt;global
	localscope;//=&amp;gt;未声明错误
	scope_without_var;//=&amp;gt;scope_without_var，注意执行checkscope后的改变&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;……………..隐藏的js文件或script结束标签&amp;lt;/ script&amp;gt;……………….&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs&quot;&gt;White:js解释器是如何工作的，声明提前是怎么回事？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;编译式和解释式的区别在于，编译式是编译后就在执行前先知先觉，解释式必须执行到相应代码才能看到，属于后知后觉。javascript是解释式的语言&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;black在模拟javascript解释器：&lt;/strong&gt; 大家好，我是一个XX浏览器的js解释器，我遵守ECMAScript的规则来处理js代码。我看到一个js文件或者一个script标签，这两者意义相同，我用js文件进行代指吧。我知道我到了工作的时候了，我首先逐行阅读这个js文件查看都声明了哪些变量或者函数，不管变量是不是通过var声明的。这时候我不执行任何表达式或语句，也不进入任何函数内部，我把”所有变量（var | no var）”和”所有函数”(通过”function run() {}”声明式的,不考虑”var run = function() {}”这种表达式的方式，后一种把var run做变量处理)都提升到任何js代码之前进行集中声明，这样我就知道了这个js文件都声明了哪些变量和函数了，我把顶级作用域的这些声明都附加成window对象的属性，便于以后的作用域链的查找。然后我又一次从原始js文件（隐藏的变量提前之前）逐行进行处理，进行遇到的各个”表达式和语句(表达式和语句的区别以后会讲解)”，直到遇到执行函数。&lt;/p&gt;

&lt;p&gt;我在顶级作用域遇到执行函数这时候，我找到了相应的函数声明，然后我就进入函数内部(有时候需要带上参数)，一下子我离开了顶级作用域，进入了这个函数的作用域了，又是一个未知的新天地，我就重复上段所做的，先看声明，再变量提前，再执行表达式和语句，直到遇到下一个函数，如此反复，遇到return返回语句我就把当前的结果返回上一级作用域或者执行完函数最后一句，这时候返回undefined。&lt;/p&gt;

&lt;p&gt;现在我又回到顶级作用域了，继续向下执行，直到js文件末尾。&lt;/p&gt;

&lt;p&gt;ok，我的工作完成了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsvarscopelocalscopevarscope_without_var&quot;&gt;White:上面js中变量声明中使用var方式”scope”,”localscope”和不使用var声明变量”scope_without_var”的区别是什么？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;注意：不使用var可以声明变量是js的一个坏特性，完全可以不使用这种做法，而且我们也应该不使用这样的声明方式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中变量声明一般使用var声明&lt;code&gt;var last_name=&amp;quot;zhang&amp;quot;;&lt;/code&gt;，如果读取还未赋值&lt;code&gt;var my_name;&lt;/code&gt;时返回undefined。也可以不是用var而不声明直接使用变量&lt;code&gt;first_name=&amp;quot;huaning&amp;quot;&lt;/code&gt;，但是读取未声明的变量&lt;code&gt;full_name//=&amp;gt;报错&lt;/code&gt;会报错。&lt;/p&gt;

&lt;p&gt;例如在最顶级作用域window作用域来说，这两种方式的区别在于，前一种方式显式声明了一个全局变量，后一种方式隐式声明了全局变量（全局属性）name，即全局对象window增加了一个新的first_name的属性。window的所有属性都是可以在js代码中以变量形式直接使用的，之所以说是window的属性是因为对于属性可以使用&lt;code&gt;delete first_name //=&amp;gt;true&lt;/code&gt;表达式返回true，而对于变量&lt;code&gt;delete last_name //=&amp;gt;false&lt;/code&gt;。区别看下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var last_name;
	last_name; //=&amp;gt; undefined
	first_name; //=&amp;gt;未声明错误
	last_name = &amp;quot;zhang&amp;quot;;
	first_name = &amp;quot;huaning&amp;quot;;
	last_name; //=&amp;gt; zhang
	first_name; //=&amp;gt;huaning

	window.hasOwnProperty(&amp;quot;last_name&amp;quot;); //=&amp;gt;true
	window.hasOwnProperty(&amp;quot;first_name&amp;quot;); //=&amp;gt;true
	delete last_name; //=&amp;gt;false
	delete first_name; //=&amp;gt;true
	last_name; //=&amp;gt; &amp;quot;&amp;quot;
	first_name; //=&amp;gt;未声明错误&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：在函数内部当不使用var声明的全局变量scope_without_var，在解释器进入函数之前是不存在的，因为解释器还不知道它的存在,解释器进入该函数后，scope_without_var才能被所有的代码使用&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h5 id=&quot;&quot;&gt;此篇太长，读到这里基本注意力涣散了，所以另起一片继续变量篇后续内容&lt;/h5&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js类型篇(二)</title>
   <link href="http://izhanghuaning.github.io/books/2011/05/05/jsdg-chap3-types-values-variables.html"/>
   <updated>2011-05-05T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/05/05/jsdg-chap3-types-values-variables</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White:类型、值、变量分别指什么，它们之间有什么联系和区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;计算机程序的运行需要对“值value”进行操作。在编程语言中，能够表示并操作的值的类型称作”数据类型type“，编程语言最基本的特性是支持多种数据类型，比如字符串、数字、布尔值、数组等等。当程序需要将一个值反复使用，就需要将其保存在一个”变量variable“中。简单来说 &lt;code&gt;var name = &amp;quot;zhn&amp;quot; &lt;/code&gt;中var是类型，”zhn“是值，name是变量。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript&quot;&gt;White:javascript是弱类型语言，这个怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;强/弱类型是指类型检查的严格程度的。语言有无类型，弱类型和强类型三种。无类型的不检查，甚至不区分指令和数据。弱类型的检查很弱，仅能严格的区分指令和数据。强类型的则严格的在编译期进行检查。&lt;/p&gt;

&lt;p&gt;像java、c#等强类型语言而言，变量和值都有自己的类型，在编译阶段就可检查类型匹配。比如&lt;code&gt;String name&lt;/code&gt;，变量name的类型是String，这是静态类型，也就是name只能被赋值字符串&lt;code&gt;name=&amp;quot;zhn&amp;quot;&lt;/code&gt;，而不能被赋值数字&lt;code&gt;name=30&lt;/code&gt;，否则编译就会报错。你也可以声明&lt;code&gt;object age&lt;/code&gt;，这样可以&lt;code&gt;age = 30, age = &amp;quot;zhn&amp;quot;&lt;/code&gt;，这样可以近似实现弱类型，不过这样会需要在运行时频繁的类型转换，不能发挥强类型的优点了。&lt;/p&gt;

&lt;p&gt;而javascript中的变量都用var来声明，比如&lt;code&gt;var name&lt;/code&gt;本身不指定具体类型，name可以被赋任何类型值，&lt;code&gt;name=&amp;quot;zhn&amp;quot;， name=3， name=new Date()， name=[1,2,3]&lt;/code&gt;等等都是可以的，所以说js是弱类型语言，就是变量无类型，值有类型。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_2&quot;&gt;White:javascript的值有哪些类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中的值分为原始类型和对象类型两大类，原始类型只有5种，分别是：字符串、数字、布尔值、null、undefined。&lt;/p&gt;

&lt;p&gt;除了原始类型其他的都是对象类型，常见的有数组Array、正则RegExp、日期Date、错误Error、普通对象Object、函数Function等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：原始类型都是不可变类型。对象类型都是可变类型。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_3&quot;&gt;White:详细介绍一下javascript原始类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;原始类型都是不可变类型。不能修改原始值本身，包括特别是字符串也不能修改。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1 var name = &amp;quot;zhn&amp;quot;; //=&amp;gt; zhn
	2 var zhn = &amp;quot;zhn&amp;quot;;  //=&amp;gt; zhn
	3 name = name.toUpperCase(); //=&amp;gt; ZHN
	4 zhn //=&amp;gt; zhn&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的行1,2中”zhn”是完全不相关的内存中的两个区域的值，行3中的toUpperCase没有改变行1中的”zhn”，而是生成了一个新的”ZHN”来进行替代，原来行1的”zhn”没有任何变量去关联它，它会被js的垃圾回收机制进行回收。而2中的”zhn”不受任何影响。&lt;/p&gt;

&lt;p&gt;原始类型中的字符串、数字、布尔值都可以被包装成相应的对象String、Number、Boolean。被包装成对象后具有相应的一些方法,比如string的sub、split、toUpperCase等方法。在包装对象的过程中有”临时对象”的概念需要注意，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1 var name = &amp;quot;zhn&amp;quot;;
	2 name.toUpperCase(); //=&amp;gt; ZHN，注意这里没有进行赋值，包装的是一个临时对象obj,然后调用了obj.toUpperCase()方法。
	3 name //=&amp;gt; zhn ，注意name依然是&amp;quot;zhn&amp;quot;，没有任何改变，行2中的临时对象obj已经被抛弃了。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原始类型中的null和undefined都代表“空”的意思,它们都是唯一值,不可被包装成对象，也就是它们没有任何方法，调用它们的任何方法都会报错。null和undefined一般来说其区别是：null代表定义了变量但未赋值的空，引用类型的变量赋空值一般也用null，&lt;code&gt;typeof null //=&amp;gt; object&lt;/code&gt;。undefined代表未定义的空，就是不存在这个变量&lt;code&gt;typeof undefined //=&amp;gt; undefined&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;null是关键字，undefined不是关键字，是一个全局变量。你或许可以认为undefined是表示系统级的，出乎意料或者类似错误的值的空缺。而null是程序级的，正常的或意料之中的值的空缺。如果需要将其赋给变量或属性或参数，最佳选择是使用null。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_4&quot;&gt;White:javascript的原始类型使用中有哪些需要注意的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 关于数字，js预定义了全局变量Infinity和NaN表示正无穷大和非数字，其中NaN和任何值都不相等，包括自身。判断Nan需要使用x != NaN进行判断。还有浮点数运算是有误差，整数没有。&lt;/p&gt;

&lt;p&gt;关于布尔值，假值只有false、“”、0、-0、null、NaN、undefined，其余都是真值，真值也就是在if语句判断中为真，假值判断为假。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_5&quot;&gt;White:详细介绍一下javascript的对象类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;对象类型都是可变的引用类型，它们的值是可修改的。&lt;em&gt;原始值的相等比较是比较值，而对象类型相等比较是比较的引用地址，如果想比较两个对象的值相等需要自己去实现方法或者简单的序列化后比较值。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;所有js的对象类型都可以看作统一看作哈希值（hash或者字典），由键、值对构成。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var zhn = { name:&amp;quot;zhanghuaning&amp;quot;, 
				age:30,
				say: function() {return &amp;quot;Hello world&amp;quot;}
			  };
	var names = [&amp;quot;zhn&amp;quot;, &amp;quot;black&amp;quot;, &amp;quot;white&amp;quot;];
	var sayHi = function(name) {return &amp;quot;Hi&amp;quot; + name;};
	zhn[&amp;quot;name&amp;quot;] //=&amp;gt; zhanghuaning
	names[0] //=&amp;gt; zhn ,数组只是键为正整数并且会自动维护length的对象。
	sayHi[&amp;quot;length&amp;quot;] //=&amp;gt;1,相当语sayHi.length取得函数的声明参数个数，function也是对象，length是它的属性。&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:介绍一下类型转换的相关内容？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 比较罗嗦并且用到不太多，常用的基本遇到2次就掌握了，等以后上一张图片慢慢看吧。&lt;/p&gt;

&lt;p&gt;这里介绍一点类型转换相关的小技巧或注意事项吧，遇到这些情况能认识就好。&lt;/p&gt;

&lt;p&gt;注意事项：==和===的区别在于前者会进行类型转换后比较&lt;code&gt;2 == &amp;quot;2&amp;quot; //=&amp;gt; true&lt;/code&gt;，后者不进行类型转换比较&lt;code&gt;2 === &amp;quot;2&amp;quot; //=&amp;gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;+优先考虑字符串&lt;code&gt;1 + &amp;quot;x&amp;quot; //=&amp;gt;&amp;quot;1x&amp;quot;&lt;/code&gt;,其他操作考虑数字&lt;code&gt;&amp;quot;2&amp;quot; * &amp;quot;3&amp;quot; //=&amp;gt;6 ,“1” - “x” //=&amp;gt;NaN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;小技巧： x + ”” 转换成字符串&lt;/p&gt;

&lt;p&gt;+x 转换成数字&lt;/p&gt;

&lt;p&gt;!!x 转换成布尔值&lt;/p&gt;

&lt;p&gt;void 0 转换成undefined&lt;/p&gt;
&lt;hr /&gt;</content>
 </entry>
 
 <entry>
   <title>BW编程之js概述篇(一)</title>
   <link href="http://izhanghuaning.github.io/books/2011/05/01/jsdg-chap1-introduction.html"/>
   <updated>2011-05-01T00:00:00+08:00</updated>
   <id>http://izhanghuaning.github.io/books/2011/05/01/jsdg-chap1-introduction</id>
   <content type="html">&lt;h4 id=&quot;white&quot;&gt;White：我是一个编程菜鸟，我想学习点关于编程的知识，从什么语言入手比较好？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 俗话说“信心要比黄金更可贵”。学习一种编程语言最终要的是它能让你喜欢它，并且有信心能掌握它，使用它。怎么样提高信心呢？首先是入手快，其次所见即所得。这样才能不停的取得成就感和满足感，提升更大的信心。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;入手快：&lt;/em&gt; JavaScript只要有浏览器（IE8以上、Chrome、FireFox等）就可以学习，不需要安装任何IDE。javascript语法简单，是弱类型语言，不需要记住很多语法知识，上手速度快。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;所见即所得：&lt;/em&gt; javascript是解释性语言，不需要经过编译即可直接运行。代码可以执行在console执行看到结果。对Dom（文档对象模型，简单来说就是网页）的操作也是即时呈现。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript&quot;&gt;White：为什么要学习javascript,它的使用场景广泛么?&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; javascript可以说是世界上使用最多的编程语言，每个网页几乎都在使用它。随着互联网的发展，大量的网站已经由静态web网页发展到了web应用，web应用需要处理大量的用户交互，这就离不开javascript的支持。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_2&quot;&gt;White:简单介绍一下javascript吧&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 好的，javascript其实主要包含几个部分：javascript语言核心(ECMAScript),客户端javascript（宿主浏览器），服务端javascript（node.js)。我们j接下来只关心前面2个部分，因为node.js我也没多少使用经验。&lt;/p&gt;

&lt;p&gt;简单来说javascript就是一种高端的、动态的、弱类型的编程语言，非常适合面向对象和函数式的编程风格。javascript的语法来自java，它的一等函数来自语scheme(一种lisp方言)，基于原型的继承来自self。我们不需要了解上面的java、scheme、self语言，因为我也不知道。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别声明:javascript和java没有任何关系，除了名字和语法有点相似，买书的时候千万不要买java的书来学习javascript。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_3&quot;&gt;White:既然谈到javascript书籍，有哪写书值得购买呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 好的，推荐这些书籍主要是为了你能够用最少的精力和金钱得到更多的知识和技能，没有任何广告和商业成分，并且这些书都是我购买并且仔细阅读过的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;基础级：JavaScript权威指南、JavaScript高级程序设计&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;进阶级：JavaScript语言精粹、基于MVC的Javacript Web富应用开发、Javacript模式、编写可维护的JavaScript（这本暂时没看完）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面几本书看完基本对于javascript也有了一定认识了，完全可以自己去探索更多javascript的美丽世界了。好书可以多读几遍，可以有更多的收获。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_4&quot;&gt;White:你为什么会写这些博客，并且javascript系列会涉及到哪些内容呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;这些年看过很多书，也看过很多其他人的博客，加深了对很多知识和技术的掌握。很多时候在看书或者看博客的时候有一些感悟，但是过一点时间不去深入研究就忘记了，所以希望能够有个笔记本来记录自己在学习技术过程中的点点滴滴。最好也能够对其他偶尔来到这里的人有所帮助，共享、免费，提倡自由、平等是每个程序员的追求。&lt;/p&gt;

&lt;p&gt;至于javascript的内容是基于上面那些书籍和一些博客的内容加上自己的一些理解，基本算是想到哪里说到哪里，可能会比较杂，但是还是尽量按照从基础到进阶的过程来组织。&lt;/p&gt;</content>
 </entry>
 
 
</feed>