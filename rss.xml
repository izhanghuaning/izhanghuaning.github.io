<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>张华宁的笔记本</title>
        <description>张华宁的笔记本 - 张华宁</description>
        <link>http://izhanghuaning.github.io</link>
        <link>http://izhanghuaning.github.io</link>
        <lastBuildDate>2014-03-14T14:42:17+08:00</lastBuildDate>
        <pubDate>2014-03-14T14:42:17+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>BW编程之js表达式篇2 eval(六)</title>
                <description>&lt;h4 id=&quot;white&quot;&gt;White:表达式计算是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js同许多解释性语言一样，可以解释并运行由js代码组成的字符串，并产生一个值。这就是表达式运算，在js中通过全局函数eval()来实现这个工作。对于eval记住一句话：”eval()是魔鬼”，能不用就不要用。&lt;/p&gt;

&lt;p&gt;eval只有一个参数，如果传入的参数不是字符串，它直接返回这个参数，否则它会把参数字符串当作js代码来解释，如果解释失败则抛出错误，成功则开始执行。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval&quot;&gt;White:eval有哪些需注意的地方？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;记住一句话：”eval()是魔鬼”，能不用就不要用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在你觉得需要使用eval方法的时候，请再三考虑一下是否有更好的方式来替代eval。&lt;/li&gt;

&lt;li&gt;eval只能执行单独有语义的代码，不能作为函数的一部分来运行，比如&lt;code&gt;eval(&amp;quot;return;&amp;quot;)//=&amp;gt;错误&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;非直接调用eval(使用&lt;code&gt;geval = eval;&lt;/code&gt;别名)时，它使用全局对象作为上下文作用域，并且无法读、写、定义局部变量和函数。&lt;/li&gt;

&lt;li&gt;eval别名调用方式允许我们执行一些对上下文没有任何依赖的代码片段。&lt;/li&gt;

&lt;li&gt;对待eval最好把它当作一个运算符，而不是一个函数。&lt;/li&gt;

&lt;li&gt;在严格模式下，eval可以查询和修改局部变量，但是不能在局部作用域定义新的变量或函数。&lt;/li&gt;

&lt;li&gt;ajax返回的json送入eval进行处理时需要对json加括号包住&lt;code&gt;eval(&amp;quot;(&amp;quot;+json+&amp;quot;)&amp;quot;)&lt;/code&gt;来转成对象处理,但是json处理一般是用JSON.parse进行解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval_2&quot;&gt;White:为什么说”eval是魔鬼”？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;主要有以下几个原因:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用eval的代码晦涩难懂，不容易维护。&lt;/li&gt;

&lt;li&gt;eval包含安全隐患，它可以执行可能被篡改过的代码，这是在处理ajax请求的json响应的常见的反模式。&lt;/li&gt;

&lt;li&gt;eval使用了调用者的变量作用域环境，即它查找变量的值和定义新变量的操作和局部作用域的代码完全一样，会改变调用者（局部或全局）的变量对象VO。&lt;/li&gt;

&lt;li&gt;优化或者js压缩工具不能很好的对包含eval的代码进行优化。&lt;/li&gt;

&lt;li&gt;setInterval()、setTimeout()、new Function()这些方法传递字符串参数的时候和eval类似，应尽量避免传递字符串给它们。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whiteeval_3&quot;&gt;White:使用哪些方式可以尽量安全eval的方式？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;有一些方式可以替换或者较好方式使用eval，主要有以下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用new Function(str)来替代eval，str中使用var定义的变量会在局部函数作用域运行，不会自动成为全局变量。&lt;/li&gt;

&lt;li&gt;使用立即函数封装eval的调用，也可避免其中var定义的变量自动成为全局变量。&lt;/li&gt;

&lt;li&gt;使用new Function的方式只能看到全局作用域，不影响局部作用域链。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs&quot;&gt;White:js中什么是表达式和运算符？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_2&quot;&gt;White:js中什么是表达式和运算符？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_3&quot;&gt;White:js中什么是表达式和运算符？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_4&quot;&gt;White:js中什么是表达式和运算符？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs_5&quot;&gt;White:js中什么是表达式和运算符？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;</description>
                <link>http://izhanghuaning.github.io/books/2011/05/25/jsdg-chap4-expression-operators2.html</link>
                <guid>http://izhanghuaning.github.io/books/2011/05/25/jsdg-chap4-expression-operators2</guid>
                <pubDate>2011-05-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>BW编程之js表达式、运算符篇(五)</title>
                <description>&lt;h4 id=&quot;whitejs&quot;&gt;White:js中什么是表达式和运算符？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在js中表达式（expression）是一个短语，js解释器会将其计算出一个结果。程序中的常量是最简单的一类表达式。变量名也是一种简单表达式，它的值就是赋值给变量的值。复杂表达式是由简单表达式组成的，常用的方法是使用运算符(operator)。运算符按照特定的运算规则对操作数进行运算，并计算出新值。&lt;/p&gt;

&lt;p&gt;表达式主要包含原始表达式(直接量(常量)、关键字(true,false，null,this)、变量），对象和数组初始化表达式（&lt;code&gt;var p = {x:2, y:3}&lt;/code&gt;、&lt;code&gt;var days = [1,2,3]&lt;/code&gt;） ，函数定义表达式（&lt;code&gt;var sum = function(a,b) {return a + b}&lt;/code&gt;)，属性访问表达式(&lt;code&gt;p.x&lt;/code&gt;、&lt;code&gt;p[&amp;quot;y&amp;quot;]&lt;/code&gt;、&lt;code&gt;days[0]&lt;/code&gt;），调用表达式（调用函数或方法的语法表示），对象创建表达式(new)，运算表达式（见下面运算符所示）等。&lt;/p&gt;

&lt;p&gt;js中的运算符主要用于算术表达式(+、-、*、/)、比较表达式(&amp;lt;、===、&amp;gt;）、逻辑表达式（&amp;amp;&amp;amp;、||、！）、赋值表达式（=）等。大多数运算符都用标点符号表示，比如+-*/，也有一些运算符用关键字表示，比如delete、instanceof、typeof、void等。运算符是有优先级和结合性(一元操作符、赋值、三元条件运算符都是右结合)的，关于运算符可参见下图：&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:什么是左值,什么是表达式副作用？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;左值是一个术语，它指“表达式只能出现在运算符的左侧”。在js中变量、对象属性、数组元素均是左值。ECMAScript规范允许内置函数返回左值，但是自定义函数不能返回左值。&lt;/p&gt;

&lt;p&gt;表达式副作用是指本来计算表达式（比如&lt;code&gt;2*3&lt;/code&gt;)不会对程序的运行状态造成任何影响，程序后续的计算也不会受到该表达式运算的影响，但是有一些表达式在即算后会产生上述影响，这就是表达式的副作用。&lt;/p&gt;

&lt;p&gt;会产生副作用的表达式有：赋值、自增、函数调用、对象创建、delete等。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:调用表达式怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;调用表达式(invocation expression）是一种调用（或者执行）函数或方法的语法表示。当调用表达式进行求值的时候，首先计算函数表达式，然后计算参数表达式，得到一组参数。然后实参的值被依次传递给形参，这些形参是定义函数时指定的，接下来执行函数体。执行后返回该函数的返回值，如果没有则返回undefined。&lt;/p&gt;

&lt;p&gt;在js中函数调用有两种方式普通调用和new调用，这两种方式调用同一个函数，其意义确实差异巨大。普通方式是通过func.apply方式来对函数过程进行调用，而new方式是对象创建表达式，详细见下面的new关键字的理解。&lt;/p&gt;

&lt;p&gt;函数表达式本身可以说没有副作用，但是因为函数体内部的语句或者表达式可能会产生副作用，所以这种情况下一般说函数表达式是有副作用的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitenew&quot;&gt;White:对象创建表达式和new关键字怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;对象创建表达式(object creation expression)创建一个对象并调用一个函数(这个函数称作构造函数)初始化对象的属性。js通过new关键字来进行对象创建，new关键字调用的函数与普通调用方式有2点不同：改变了上下文和改变了返回值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;new的本质&lt;/em&gt;&lt;/strong&gt;，new关键字本质上也是调用函数的方式（普通函数调用是通过func.apply或func.call方式调用），它的特殊性在于把函数当作构造函数来执行，并最终创建一个对象。其过程如下：js解释器new关键字时知道是创建对象的时候了，首先传见一个新的空对象（{}），然后把这个对象赋值给this（自定义函数无法给this赋值），再调用构造函数把传入的参数和构造函数中赋值给this的属性都作为新对象的属性，如果构造函数没有return则把这个构造好新对象作为返回值，如果有return则把其返回的对象作为最后的返回值，即创建表达式计算的值。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_3&quot;&gt;White:比较运算符中的==和===的区别是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;简单来说==会进行类型转换后比较，而===不进行类型转换直接比较，===也是严格比较,应该只使用===。&lt;/p&gt;

&lt;p&gt;===规则为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果两个值类型不同，则它们不相等。&lt;/li&gt;

&lt;li&gt;如果两个值都是null或者undefined，则它们不相等。&lt;/li&gt;

&lt;li&gt;如果两个值都是true或者都是false，则相等。&lt;/li&gt;

&lt;li&gt;任何一个是NaN则不相等，NaN需要使用!==来判断。&lt;/li&gt;

&lt;li&gt;如果两个值为数字且数值相等，则相等。0和-0相等。&lt;/li&gt;

&lt;li&gt;两个字符串只有它们所对应存储的16位数字完全相等，则它们相等。（字符串实际上是16位整数数值组成的序列，同一字符串但编码不同就是2个不同的整数序列，所以不相等。）&lt;/li&gt;

&lt;li&gt;如果两个引用值指向同一个对象、数组或者函数，则相等，只比较引用不考虑具体的值的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==规则就是===规则然后每一个都允许进行类型转换后尝试比较，比如&lt;code&gt;null==undefined //=&amp;gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;对象转换原始值是除了日期先进行toString，其他都是先valueof后调用toString进行转换。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_4&quot;&gt;White:对象转换为原始值有哪些规则？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;所有对象都继承了2个转换方法，第一个是toString（），它的作用是返回一个反映对象的字符串，默认是&lt;code&gt;[object Object]&lt;/code&gt;,我们可以通过Object.prototype.toString.call(o)来得到o的实际类型，比如&lt;code&gt;[object String]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第二个是valueof()，如果存在任意原始值，它就默认将对象转换未它的原始值。但是大多数对象无法真正表示为一个原始值，因此默认的valueof简单返回对象本身，而不是一个原始值。&lt;/p&gt;

&lt;p&gt;对象到字符串的转换步骤（先toString后valueof）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if(o.has_method(toString) &amp;amp;&amp;amp; o.toString()===&amp;quot;原始值&amp;quot;)
	{
		return o.toString().转成字符串;
	} else if(o.has_method(valueof) &amp;amp;&amp;amp; o.valueof() === &amp;quot;原始值&amp;quot;)
	{
		return o.valueof().转成字符串；
	} else
	{
		throw 异常；
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象到数字的转换步骤（先valueof后toString）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if(o.has_method(valueof) &amp;amp;&amp;amp; o.valueof() === &amp;quot;原始值&amp;quot;)
	{
		return o.valueof().转成数字；
	} else if(o.has_method(toString) &amp;amp;&amp;amp; o.toString()===&amp;quot;原始值&amp;quot;)
	{
		return o.toString().数字;
	} else
	{
		throw 异常；
	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象转换原始值是除了日期先进行toString，其他都是先valueof后调用toString进行转换。&lt;/p&gt;
&lt;hr /&gt;</description>
                <link>http://izhanghuaning.github.io/books/2011/05/20/jsdg-chap4-expression-operators.html</link>
                <guid>http://izhanghuaning.github.io/books/2011/05/20/jsdg-chap4-expression-operators</guid>
                <pubDate>2011-05-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>BW编程之js变量篇2(四)</title>
                <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;本篇定位于进阶篇，初次接触javascript的可跳过本篇&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;whitejsstackheap&quot;&gt;White:什么是上下文调用栈，js中的栈(stack)和堆(heap)的理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;正如前一篇模拟js解释器所示，js代码初始所在的作用域为顶级作用域。js只有一种作用域即函数作用域，每当代码执行到一个函数的时候，暂停执行外层作用域,并保留当前代码的上下文和执行位置，然后进入一个新的作用域，产生一个新的上下文，如此反复就构成了一个上下文栈式结构，每一层都是一个作用域范围即一个上下文，进入新的作用域类似于入栈push一个新上下文，从内层作用域返回类似于出栈pop出当前上下文，所以叫做上下文调用栈。当代码在内层作用域执行完以后返回外部作用域的代码位置，丢掉内层的上下文(闭包情况例外)，使用外层上下文继续向下进行,所有函数执行完返回顶级作用域，这时候window对象作为当前上下文对象（变量对象VO），当前包含上下文的对象即活动对象。&lt;/p&gt;

&lt;p&gt;说到堆栈，很多人当希望深入了解某些代码的执行过程（比如java、c#、javascript等），喜欢模拟内存中数据进行分析，这是一个很好的方法,对于理解程序很有帮助。在java中原始值是通过栈来维护的，而引用值是通过堆来管理的，这主要是考虑程序的效率，栈速度快但容量小，堆容量大但相对慢，堆里面的对象是通过new的方式来分配空间并创建的，也涉及到垃圾回收的管理。&lt;/p&gt;

&lt;p&gt;但是在javascript对我们可以说只有堆，没有栈结构，因为有变量对象VO的概念，所以所有的数据都是以堆的形式管理的，解释器不直接取数据，都是通过变量对象VO取数据，这是很重要的一点，尤其是想要理解闭包的概念。javascript的内存中数据结构很简单VO作为上下文，通过链表的形式链接所有的VO，链接起来就是上下文调用栈，这里的栈只是一个描述性概念，不是内存管理数据的方式，所以&lt;strong&gt;&lt;em&gt;“正式的称呼叫作用域链”&lt;/em&gt;&lt;/strong&gt;，凸显了链这个结构。&lt;/p&gt;

&lt;p&gt;下面会继续讲解VO概念。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitevariable_objectactive_object&quot;&gt;White:什么是变量对象（variable object）和活动对象(active object)？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;如前所述，声明全局变量，它会成为一个全局对象window的一个属性，那么局部变量呢，按照统一性进行推论应该成为某个对象的属性。这个对象即是假设的上下文对象VO。当代码执行的时候，会形成一个作用域链，在每个作用域有一个由很多变量、参数、函数等组成的上下文，包含上下文中的内容的对象被成为变量对象VO，解释器正在执行的作用域的VO就是活动对象AO。&lt;/p&gt;

&lt;p&gt;VO对象对我们是透明（不可见）的，它由解释器来创建和维护的，我们代码不能操作VO。但是我们可以通过chrome等的开发者工具可以查看到scope variables即作用域链，里面有各个VO。我假设的VO对象结构是下面这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var VO = {
		var1:&amp;quot;var1&amp;quot;,
		function1:function() {},
		arg1:arg1,
		.//变量、函数、参数都编程了VO对象的属性
		.//还有个作用域链的属性和this属性
		.//注意：表达式不能成为VO的属性
		ScopeChains:[VO的上面的属性 + 上级ScopeChains],
		this:特殊值//=》函数的调用者被关联到this。

	}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ScopeChains和this两个属性不进入作用域链查找，查找时先看当前VO有没有相应属性，没有则进入上一级的ScopeChains查找。this是javascript的最核心内容（也可能是之一），后面应该也要单独讲解。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitevo__proto__objectprototype&quot;&gt;White:VO既然是个对象，那么它的原型(__proto__)是什么？对象Object.prototype？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;我有个假设是函数级VO的原型是null，因为我在chrome的开发者工具做了如下测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	function test() { return toString() }
	test();//=&amp;gt;[object window]
	window.toString = function() {return &amp;quot;window toString&amp;quot;}
	test();//=&amp;gt;window toString&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试中的toString()方法在test的作用域没有定义，但是Object中有这个方法，它的返回值就是[object xxxx]的形式，所以第一次调用的就是Object的toString方法。这个调用是调用的VO的原型的toString方法还是通过window调用的呢？所以把window的toString重写，然后再次调用，发现是调用的window的toString方法。根据作用域链，解释器应该先从test的VO寻找toString方法，既然是从VO对象中查找属性则涉及到原型链查找，如果VO的原型链有Object，应该会直接调用Object的toSring方法。但是后面证实解释器是从test的VO，找到window的VO,然后调用的window的toString方法，所以我假设VO的原型(__proto__)是null，所以VO直接沿着作用域链的VO查找所有参数、变量和函数，而不会去原型链查找。&lt;/p&gt;

&lt;p&gt;但是到了window的VO呢？似乎不能满足上面假说，因为调用了window的toString方法，这个方法是从其原型链的Object得到的，这里是有冲突的，所以我的另一个假说是window的VO引用了window自身，从chrome也可以看到这个意思(Global window)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里的假说有待商榷，希望有了解的能够指正，我没有去研究js引擎的内容，谢谢&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white&quot;&gt;White:作用域链是如何形成的呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;在最顶级作用域中，作用域链只有一个全局对象组成，即window VO。在不包含嵌套函数的函数体内，作用域链上有两个对象，第一个是函数自身VO，还有其外层的window VO。如果函数中还有嵌套函数，那么内部嵌套函数的作用域链就是自身VO + 所有的外层ScopeChains，一直包含到window VO。作用域链是在解释器进入函数的时候进行重新定义（或者说延伸），不断进行 新的ScopeChains = 自身VO + 外层ScopeChains。&lt;/p&gt;

&lt;p&gt;嵌套函数更加特殊的地方在于，因为作用域链是在进入函数时重新定义的，所以嵌套函数的作用域链在每次执行外部函数时定义的，虽然嵌套函数的代码相同，但关联这段代码的作用域链却不相同。&lt;/p&gt;

&lt;p&gt;作用域链有几个特殊情形是with和try…catch,这两种情况都会产生一个新的作用域上下文即变量对象VO,附加到整个作用域链最前面，即在with中的ScopeChains = with_VO + 当前函数Scopehains。try…catch也是一样的。&lt;/p&gt;
&lt;hr /&gt;</description>
                <link>http://izhanghuaning.github.io/books/2011/05/15/jsdg-chap3-types-values-variables3.html</link>
                <guid>http://izhanghuaning.github.io/books/2011/05/15/jsdg-chap3-types-values-variables3</guid>
                <pubDate>2011-05-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>BW编程之js变量篇(三)</title>
                <description>&lt;h4 id=&quot;white&quot;&gt;White:变量是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;正如前面类型篇所讲，变量就是一个标签，贴到了“值alue”上面，代码可以通过变量来操作它所代表的值，主要是为了方便复用。&lt;/p&gt;

&lt;p&gt;变量根据是否可以改变分为普通变量和常量，常量就是赋值之后不能二次赋值（改变）的特殊只读变量，js没有真正声明常量的语法，基本是约定俗称的全大写的变量表示常量。&lt;/p&gt;

&lt;p&gt;js的变量根据其作用域(有效范围)分为私有变量、局部变量、全局变量等，js的作用域只有函数作用域，外层作用域的变量可以穿透作用域到内层作用域，当内外层作用域的变量冲突的话，内层作用域的变量起作用（覆盖了外层），这实际上是变量的作用域链的查找规则决定的，后面会深入探讨作用域链。还有一种特殊的能跨作用域的变量是闭包的概念，这也是一个进阶的内容，放在后面单独开出一章来讲解。一句话理解闭包就是从作用域A操作（访问）作用域B中的变量,基本是指外部访问内部作用域的变量。&lt;/p&gt;

&lt;p&gt;js中没有真正声明私有变量的语法，约定俗称是变量前面或者后面加上一个或两个下划线表示该变量为私有变量（_name,name_,__proto__等），作者不希望其他人使用这些变量，此所谓防君子不防小人，别人照样能随意操作你的私有变量。真正实现的私有变量是通过闭包来实现的，但是性能效率比较低，后面讲解闭包会详细说明。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:变量作用域是什么？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;变量的作用域是指”程序源代码中定义这个变量”的区域。js的作用域只有一种，函数作用域。全局作用域可以看作一种特殊的函数作用域，类似语程序的入口函数(main)的概念，所有的js代码都是在全局作用域被解释器顺序解释并执行，遇到执行函数时则进入函数作用域(function)解释并执行。&lt;/p&gt;

&lt;p&gt;全局对象（一般是window）是js解释器加载js代码时候创建的特殊对象（上下文对象或活动对象），所有未声明在其他函数作用域(function)的变量、函数都会成为window对象的属性，它们在代码中的任何地方（所有作用域中）都是可见的。如下所示：&lt;/p&gt;

&lt;p&gt;……………隐藏的js文件或script开始标签&amp;lt; script&amp;gt;………………..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var scope = &amp;quot;global&amp;quot;;
	function checkscope() {
		var localscope = &amp;quot;local&amp;quot;;
		scope_without_var = &amp;quot;scope_without_var&amp;quot;;
		return scope + &amp;quot; &amp;quot; + localscope + &amp;quot; &amp;quot; + scope_without_var;
	}
	scope;//=&amp;gt;global
	localscope;//=&amp;gt;未声明错误
	scope_without_var;//=&amp;gt;未声明错误,注意还没有执行checkscope，解释器还不知道它的存在
	
	checkscope();//=&amp;gt;global local scope_without_var，这里执行了checkscope
	
	scope;//=&amp;gt;global
	localscope;//=&amp;gt;未声明错误
	scope_without_var;//=&amp;gt;scope_without_var，注意执行checkscope后的改变&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;……………..隐藏的js文件或script结束标签&amp;lt;/ script&amp;gt;……………….&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejs&quot;&gt;White:js解释器是如何工作的，声明提前是怎么回事？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;编译式和解释式的区别在于，编译式是编译后就在执行前先知先觉，解释式必须执行到相应代码才能看到，属于后知后觉。javascript是解释式的语言&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;black在模拟javascript解释器：&lt;/strong&gt; 大家好，我是一个XX浏览器的js解释器，我遵守ECMAScript的规则来处理js代码。我看到一个js文件或者一个script标签，这两者意义相同，我用js文件进行代指吧。我知道我到了工作的时候了，我首先逐行阅读这个js文件查看都声明了哪些变量或者函数，不管变量是不是通过var声明的。这时候我不执行任何表达式或语句，也不进入任何函数内部，我把”所有变量（var | no var）”和”所有函数”(通过”function run() {}”声明式的,不考虑”var run = function() {}”这种表达式的方式，后一种把var run做变量处理)都提升到任何js代码之前进行集中声明，这样我就知道了这个js文件都声明了哪些变量和函数了，我把顶级作用域的这些声明都附加成window对象的属性，便于以后的作用域链的查找。然后我又一次从原始js文件（隐藏的变量提前之前）逐行进行处理，进行遇到的各个”表达式和语句(表达式和语句的区别以后会讲解)”，直到遇到执行函数。&lt;/p&gt;

&lt;p&gt;我在顶级作用域遇到执行函数这时候，我找到了相应的函数声明，然后我就进入函数内部(有时候需要带上参数)，一下子我离开了顶级作用域，进入了这个函数的作用域了，又是一个未知的新天地，我就重复上段所做的，先看声明，再变量提前，再执行表达式和语句，直到遇到下一个函数，如此反复，遇到return返回语句我就把当前的结果返回上一级作用域或者执行完函数最后一句，这时候返回undefined。&lt;/p&gt;

&lt;p&gt;现在我又回到顶级作用域了，继续向下执行，直到js文件末尾。&lt;/p&gt;

&lt;p&gt;ok，我的工作完成了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejsvarscopelocalscopevarscope_without_var&quot;&gt;White:上面js中变量声明中使用var方式”scope”,”localscope”和不使用var声明变量”scope_without_var”的区别是什么？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;注意：不使用var可以声明变量是js的一个坏特性，完全可以不使用这种做法，而且我们也应该不使用这样的声明方式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中变量声明一般使用var声明&lt;code&gt;var last_name=&amp;quot;zhang&amp;quot;;&lt;/code&gt;，如果读取还未赋值&lt;code&gt;var my_name;&lt;/code&gt;时返回undefined。也可以不是用var而不声明直接使用变量&lt;code&gt;first_name=&amp;quot;huaning&amp;quot;&lt;/code&gt;，但是读取未声明的变量&lt;code&gt;full_name//=&amp;gt;报错&lt;/code&gt;会报错。&lt;/p&gt;

&lt;p&gt;例如在最顶级作用域window作用域来说，这两种方式的区别在于，前一种方式显式声明了一个全局变量，后一种方式隐式声明了全局变量（全局属性）name，即全局对象window增加了一个新的first_name的属性。window的所有属性都是可以在js代码中以变量形式直接使用的，之所以说是window的属性是因为对于属性可以使用&lt;code&gt;delete first_name //=&amp;gt;true&lt;/code&gt;表达式返回true，而对于变量&lt;code&gt;delete last_name //=&amp;gt;false&lt;/code&gt;。区别看下面代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var last_name;
	last_name; //=&amp;gt; undefined
	first_name; //=&amp;gt;未声明错误
	last_name = &amp;quot;zhang&amp;quot;;
	first_name = &amp;quot;huaning&amp;quot;;
	last_name; //=&amp;gt; zhang
	first_name; //=&amp;gt;huaning

	window.hasOwnProperty(&amp;quot;last_name&amp;quot;); //=&amp;gt;true
	window.hasOwnProperty(&amp;quot;first_name&amp;quot;); //=&amp;gt;true
	delete last_name; //=&amp;gt;false
	delete first_name; //=&amp;gt;true
	last_name; //=&amp;gt; &amp;quot;&amp;quot;
	first_name; //=&amp;gt;未声明错误&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：在函数内部当不使用var声明的全局变量scope_without_var，在解释器进入函数之前是不存在的，因为解释器还不知道它的存在,解释器进入该函数后，scope_without_var才能被所有的代码使用&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h5 id=&quot;&quot;&gt;此篇太长，读到这里基本注意力涣散了，所以另起一片继续变量篇后续内容&lt;/h5&gt;</description>
                <link>http://izhanghuaning.github.io/books/2011/05/10/jsdg-chap3-types-values-variables2.html</link>
                <guid>http://izhanghuaning.github.io/books/2011/05/10/jsdg-chap3-types-values-variables2</guid>
                <pubDate>2011-05-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>BW编程之js类型篇(二)</title>
                <description>&lt;h4 id=&quot;white&quot;&gt;White:类型、值、变量分别指什么，它们之间有什么联系和区别？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;计算机程序的运行需要对“值value”进行操作。在编程语言中，能够表示并操作的值的类型称作”数据类型type“，编程语言最基本的特性是支持多种数据类型，比如字符串、数字、布尔值、数组等等。当程序需要将一个值反复使用，就需要将其保存在一个”变量variable“中。简单来说 &lt;code&gt;var name = &amp;quot;zhn&amp;quot; &lt;/code&gt;中var是类型，”zhn“是值，name是变量。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript&quot;&gt;White:javascript是弱类型语言，这个怎么理解？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;强/弱类型是指类型检查的严格程度的。语言有无类型，弱类型和强类型三种。无类型的不检查，甚至不区分指令和数据。弱类型的检查很弱，仅能严格的区分指令和数据。强类型的则严格的在编译期进行检查。&lt;/p&gt;

&lt;p&gt;像java、c#等强类型语言而言，变量和值都有自己的类型，在编译阶段就可检查类型匹配。比如&lt;code&gt;String name&lt;/code&gt;，变量name的类型是String，这是静态类型，也就是name只能被赋值字符串&lt;code&gt;name=&amp;quot;zhn&amp;quot;&lt;/code&gt;，而不能被赋值数字&lt;code&gt;name=30&lt;/code&gt;，否则编译就会报错。你也可以声明&lt;code&gt;object age&lt;/code&gt;，这样可以&lt;code&gt;age = 30, age = &amp;quot;zhn&amp;quot;&lt;/code&gt;，这样可以近似实现弱类型，不过这样会需要在运行时频繁的类型转换，不能发挥强类型的优点了。&lt;/p&gt;

&lt;p&gt;而javascript中的变量都用var来声明，比如&lt;code&gt;var name&lt;/code&gt;本身不指定具体类型，name可以被赋任何类型值，&lt;code&gt;name=&amp;quot;zhn&amp;quot;， name=3， name=new Date()， name=[1,2,3]&lt;/code&gt;等等都是可以的，所以说js是弱类型语言，就是变量无类型，值有类型。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_2&quot;&gt;White:javascript的值有哪些类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;js中的值分为原始类型和对象类型两大类，原始类型只有5种，分别是：字符串、数字、布尔值、null、undefined。&lt;/p&gt;

&lt;p&gt;除了原始类型其他的都是对象类型，常见的有数组Array、正则RegExp、日期Date、错误Error、普通对象Object、函数Function等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：原始类型都是不可变类型。对象类型都是可变类型。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_3&quot;&gt;White:详细介绍一下javascript原始类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;原始类型都是不可变类型。不能修改原始值本身，包括特别是字符串也不能修改。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1 var name = &amp;quot;zhn&amp;quot;; //=&amp;gt; zhn
	2 var zhn = &amp;quot;zhn&amp;quot;;  //=&amp;gt; zhn
	3 name = name.toUpperCase(); //=&amp;gt; ZHN
	4 zhn //=&amp;gt; zhn&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的行1,2中”zhn”是完全不相关的内存中的两个区域的值，行3中的toUpperCase没有改变行1中的”zhn”，而是生成了一个新的”ZHN”来进行替代，原来行1的”zhn”没有任何变量去关联它，它会被js的垃圾回收机制进行回收。而2中的”zhn”不受任何影响。&lt;/p&gt;

&lt;p&gt;原始类型中的字符串、数字、布尔值都可以被包装成相应的对象String、Number、Boolean。被包装成对象后具有相应的一些方法,比如string的sub、split、toUpperCase等方法。在包装对象的过程中有”临时对象”的概念需要注意，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	1 var name = &amp;quot;zhn&amp;quot;;
	2 name.toUpperCase(); //=&amp;gt; ZHN，注意这里没有进行赋值，包装的是一个临时对象obj,然后调用了obj.toUpperCase()方法。
	3 name //=&amp;gt; zhn ，注意name依然是&amp;quot;zhn&amp;quot;，没有任何改变，行2中的临时对象obj已经被抛弃了。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原始类型中的null和undefined都代表“空”的意思,它们都是唯一值,不可被包装成对象，也就是它们没有任何方法，调用它们的任何方法都会报错。null和undefined一般来说其区别是：null代表定义了变量但未赋值的空，引用类型的变量赋空值一般也用null，&lt;code&gt;typeof null //=&amp;gt; object&lt;/code&gt;。undefined代表未定义的空，就是不存在这个变量&lt;code&gt;typeof undefined //=&amp;gt; undefined&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;null是关键字，undefined不是关键字，是一个全局变量。你或许可以认为undefined是表示系统级的，出乎意料或者类似错误的值的空缺。而null是程序级的，正常的或意料之中的值的空缺。如果需要将其赋给变量或属性或参数，最佳选择是使用null。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_4&quot;&gt;White:javascript的原始类型使用中有哪些需要注意的？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 关于数字，js预定义了全局变量Infinity和NaN表示正无穷大和非数字，其中NaN和任何值都不相等，包括自身。判断Nan需要使用x != NaN进行判断。还有浮点数运算是有误差，整数没有。&lt;/p&gt;

&lt;p&gt;关于布尔值，假值只有false、“”、0、-0、null、NaN、undefined，其余都是真值，真值也就是在if语句判断中为真，假值判断为假。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_5&quot;&gt;White:详细介绍一下javascript的对象类型？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;对象类型都是可变的引用类型，它们的值是可修改的。&lt;em&gt;原始值的相等比较是比较值，而对象类型相等比较是比较的引用地址，如果想比较两个对象的值相等需要自己去实现方法或者简单的序列化后比较值。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;所有js的对象类型都可以看作统一看作哈希值（hash或者字典），由键、值对构成。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var zhn = { name:&amp;quot;zhanghuaning&amp;quot;, 
				age:30,
				say: function() {return &amp;quot;Hello world&amp;quot;}
			  };
	var names = [&amp;quot;zhn&amp;quot;, &amp;quot;black&amp;quot;, &amp;quot;white&amp;quot;];
	var sayHi = function(name) {return &amp;quot;Hi&amp;quot; + name;};
	zhn[&amp;quot;name&amp;quot;] //=&amp;gt; zhanghuaning
	names[0] //=&amp;gt; zhn ,数组只是键为正整数并且会自动维护length的对象。
	sayHi[&amp;quot;length&amp;quot;] //=&amp;gt;1,相当语sayHi.length取得函数的声明参数个数，function也是对象，length是它的属性。&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;white_2&quot;&gt;White:介绍一下类型转换的相关内容？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 比较罗嗦并且用到不太多，常用的基本遇到2次就掌握了，等以后上一张图片慢慢看吧。&lt;/p&gt;

&lt;p&gt;这里介绍一点类型转换相关的小技巧或注意事项吧，遇到这些情况能认识就好。&lt;/p&gt;

&lt;p&gt;注意事项：==和===的区别在于前者会进行类型转换后比较&lt;code&gt;2 == &amp;quot;2&amp;quot; //=&amp;gt; true&lt;/code&gt;，后者不进行类型转换比较&lt;code&gt;2 === &amp;quot;2&amp;quot; //=&amp;gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;+优先考虑字符串&lt;code&gt;1 + &amp;quot;x&amp;quot; //=&amp;gt;&amp;quot;1x&amp;quot;&lt;/code&gt;,其他操作考虑数字&lt;code&gt;&amp;quot;2&amp;quot; * &amp;quot;3&amp;quot; //=&amp;gt;6 ,“1” - “x” //=&amp;gt;NaN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;小技巧： x + ”” 转换成字符串&lt;/p&gt;

&lt;p&gt;+x 转换成数字&lt;/p&gt;

&lt;p&gt;!!x 转换成布尔值&lt;/p&gt;

&lt;p&gt;void 0 转换成undefined&lt;/p&gt;
&lt;hr /&gt;</description>
                <link>http://izhanghuaning.github.io/books/2011/05/05/jsdg-chap3-types-values-variables.html</link>
                <guid>http://izhanghuaning.github.io/books/2011/05/05/jsdg-chap3-types-values-variables</guid>
                <pubDate>2011-05-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>BW编程之js概述篇(一)</title>
                <description>&lt;h4 id=&quot;white&quot;&gt;White：我是一个编程菜鸟，我想学习点关于编程的知识，从什么语言入手比较好？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 俗话说“信心要比黄金更可贵”。学习一种编程语言最终要的是它能让你喜欢它，并且有信心能掌握它，使用它。怎么样提高信心呢？首先是入手快，其次所见即所得。这样才能不停的取得成就感和满足感，提升更大的信心。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;入手快：&lt;/em&gt; JavaScript只要有浏览器（IE8以上、Chrome、FireFox等）就可以学习，不需要安装任何IDE。javascript语法简单，是弱类型语言，不需要记住很多语法知识，上手速度快。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;所见即所得：&lt;/em&gt; javascript是解释性语言，不需要经过编译即可直接运行。代码可以执行在console执行看到结果。对Dom（文档对象模型，简单来说就是网页）的操作也是即时呈现。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript&quot;&gt;White：为什么要学习javascript,它的使用场景广泛么?&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; javascript可以说是世界上使用最多的编程语言，每个网页几乎都在使用它。随着互联网的发展，大量的网站已经由静态web网页发展到了web应用，web应用需要处理大量的用户交互，这就离不开javascript的支持。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_2&quot;&gt;White:简单介绍一下javascript吧&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 好的，javascript其实主要包含几个部分：javascript语言核心(ECMAScript),客户端javascript（宿主浏览器），服务端javascript（node.js)。我们j接下来只关心前面2个部分，因为node.js我也没多少使用经验。&lt;/p&gt;

&lt;p&gt;简单来说javascript就是一种高端的、动态的、弱类型的编程语言，非常适合面向对象和函数式的编程风格。javascript的语法来自java，它的一等函数来自语scheme(一种lisp方言)，基于原型的继承来自self。我们不需要了解上面的java、scheme、self语言，因为我也不知道。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别声明:javascript和java没有任何关系，除了名字和语法有点相似，买书的时候千万不要买java的书来学习javascript。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_3&quot;&gt;White:既然谈到javascript书籍，有哪写书值得购买呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt; 好的，推荐这些书籍主要是为了你能够用最少的精力和金钱得到更多的知识和技能，没有任何广告和商业成分，并且这些书都是我购买并且仔细阅读过的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;基础级：JavaScript权威指南、JavaScript高级程序设计&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;进阶级：JavaScript语言精粹、基于MVC的Javacript Web富应用开发、Javacript模式、编写可维护的JavaScript（这本暂时没看完）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面几本书看完基本对于javascript也有了一定认识了，完全可以自己去探索更多javascript的美丽世界了。好书可以多读几遍，可以有更多的收获。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;whitejavascript_4&quot;&gt;White:你为什么会写这些博客，并且javascript系列会涉及到哪些内容呢？&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Black:&lt;/em&gt;这些年看过很多书，也看过很多其他人的博客，加深了对很多知识和技术的掌握。很多时候在看书或者看博客的时候有一些感悟，但是过一点时间不去深入研究就忘记了，所以希望能够有个笔记本来记录自己在学习技术过程中的点点滴滴。最好也能够对其他偶尔来到这里的人有所帮助，共享、免费，提倡自由、平等是每个程序员的追求。&lt;/p&gt;

&lt;p&gt;至于javascript的内容是基于上面那些书籍和一些博客的内容加上自己的一些理解，基本算是想到哪里说到哪里，可能会比较杂，但是还是尽量按照从基础到进阶的过程来组织。&lt;/p&gt;</description>
                <link>http://izhanghuaning.github.io/books/2011/05/01/jsdg-chap1-introduction.html</link>
                <guid>http://izhanghuaning.github.io/books/2011/05/01/jsdg-chap1-introduction</guid>
                <pubDate>2011-05-01T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
